# [데이터베이스 구축] - 1)논리 데이터베이스 설계2







## 1. 식별자

### 1.1 식별자의 정의 및 분류

+ 하나의 개체 내에서 각각의 인스턴스를 유일하게 구분할 수 있는 구분자로, 모든 개체는 한 개 이상의 식별자를 반드시 가져야 한다.

  + 식별자는 개체 내에서 대표성 여부, 스스로 생성 여부, 단일 속성 여부, 대체 여부에 따라 다음과 같이 분류

  + | 분류             | 식별자                   |
    | ---------------- | ------------------------ |
    | 대표성 여부      | 주 식별자, 보조 식별자   |
    | 스스로 생성 여부 | 내부 식별자, 외부 식별자 |
    | 단일 속성 여부   | 단일 식별자, 복합 식별자 |
    | 대체 여부        | 원조 식별자, 대리 식별자 |

    



### 1.2 주 식별자 / 보조 식별자

+ 주 식별자는 개체를 대표하는 유일한 식별자
  + 업무에 가장 적합한 속성이 주 식별자가 된다.
  + **유일성, 최소성, 불변성, 존재성**
    + 식별자를 구성하는 속성의 수가 최소, 불변, 식별자 속성에 반드시 데이터 값이 존재해야 함
+ 보조 식별자는 주 식별자를 대신하여 개체를 식별할 수 있는 **속성**
+ 두 식별자 모두 개체를 유일하게 식별할 수 있어야 한다.
+ **하나의 개체에 주 식별자는 한 개만 존재하지만 보조 식별자는 한 개 이상 존재한다.**

+ **물리적 테이블에서 주 식별자는 기본키(Prime Key)로, 보조 식별자는 유니크 인덱스(Unique Index)로 지정되어 사용된다.**





### 1.3 내부 식별자 / 외부 식별자

+ 외부 식별자는 다른 개체와의 관계에 의해 외부 개체의 식별자를 가져와 사용하는 식별자이다.
  + 자신의 개체에서 **다른 개체를 찾아가는** **연결자 역할**을 한다.





### 1.4 단일 식별자 / 복합 식별자

+ 복합 식별자는 두 개 이상의 속성으로 구성된 식별자
  + ex) 주문이라는 행위에서 주문이 고객번호와 주문번호를 함께 식별자로 할 때





### 1.5 원조 식별자 / 대리 식별자

+ 원조 식별자는 업무에 의해 만들어지는 가공되지 않은 원래의 식별자
+ 대리 식별자는 **주 식별자의 속성이 두 개 이상인 경우 속성들을 하나의 속성으로 묶어 사용하는 식별자**





### 1.6 대리 식별자의 조건

+ 최대한 범용적인 값을 사용
+ 유일한 값을 만들기 위해 대리 식별자 사용(고객 번호와 주문 번호를 합쳐 발송 번호를 만들기)
+ **편의성**과 **단순성**, **의미의 체계화**를 위한 대리 식별자를 사용할 수 있음





### 1.7 후보 식별자

+ 후보 식별자는 개체에서 각 인스턴스를 유일하게 식별할 수 있는 속성 또는 속성 집합
+ 하나의 개체에는 하나 이상의 후보 식별자가 있고, 이 중 개체의 대표성을 나타내는 식별자를 주 식별자로, 나머지는 보조 식별자로 지정한다.
+ **널 값이 될 수 없다.**





## 2. E-R 모델

### 2.1 E-R 모델의 개요

+ E-R 모델은 **개념적 데이터 모델**의 가장 대표적인 것으로, 1976년 피터 첸에 의해 제안되고 기본적인 구성 요소가 정립되었다.
+ 개체와 개체 간의 **관계**를 기본 요소로 이용하여 **현실 세계의 무질서한 데이터를 개념적인 논리 데이터**로 표현하기 위한 방법

+ 개체 타입과 이들 간의 관계 타입을 이용해 현실 세계를 개념적으로 표현
+ **데이터를 개체, 관계, 속성으로 묘사**





### 2.2 E-R 다이어그램

| 기호 이름     | 의미                                                 |
| ------------- | ---------------------------------------------------- |
| 사각형 (중요) | 개체 타입                                            |
| 마름모 (중요) | 관계 타입                                            |
| 타원 (중요)   | 속성                                                 |
| 이중 타원     | 다중값 속성(복합 속성)                               |
| 밑줄 타원     | 기본키 속성                                          |
| 복수 타원     | 복합 속성(ex) 성명은 성과 이름)                      |
| 관계          | 개체 관계에 대한 대응수를 선 위에 기술(1:1, 1:N N:M) |
| 선, 링크      | 개체 타입과 속성을 연결                              |

![논리데이터베이스 - 개체-관계(E-R)모델 - Hello Engineering](https://hyeonukdev.github.io/images/%EC%A0%95%EB%B3%B4%EC%B2%98%EB%A6%AC%EA%B8%B0%EC%82%AC/0514_02.png)







## 3. 관계형 데이터 모델

### 3.1 관계형 데이터 모델의 개요

+ 가장 널리 사용되는 데이터 모델로, **2차원적인 표**를 이용해서 데이터 상호 관계를 정의하는 DB구조
+ 테이블 내에 있는 속성들 간의 관계를 설정하거나 테이블 간의 관계를 설정하여 이용
+ **기본키**와 **외래키**로 데이터 간의 관계를 표현
+ 관계형 모델의 대표적인 언어는 SQL





### 3.2 관계형 데이터 모델의 구성

![관계형 데이터 모델](https://blog.kakaocdn.net/dn/dh0fDu/btqyQUf4jv9/jpx17EeZl8wzKhpDyMRGQk/img.png)







## 4. 관계형 데이터베이스의 구조

### 4.1 관계형 데이터베이스의 개요

+ IBM에 근무하던 코드(Codd)에 의해 처음 제안되었다.
+ 관계형 데이터베이스를 구성하는 개체나 관계를 모두 **릴레이션**이라는 표로 표현한다.
+ 릴레이션은 개체를 표현하는 **개체 릴레이션**, 관계를 나타내는 **관계 릴레이션**으로 구분할 수 있다.
+ 장점
  + 간결하고 보기 편리하며 다른 DB로의 변환이 용이
+ 단점
  + 성능이 다소 떨어짐





### 4.2 관계형 데이터베이스의 Relation 구조

+ 릴레이션은 데이터들을 **표(Table)**형태로 표현한 것으로 구조를 나타내는 **릴레이션 스키마**(보통 첫 행)와 실제 값들인 **릴레이션 인스턴스**(나머지 행)로 구성
+ **튜플**
  + 릴레이션을 구성하는 각각의 행
  + 속성의 모임
  + 파일의 구조에서의 레코드와 같은 의미
  + 튜플의 수를 **카디널리티** 또는 **기수**, **대응수**라고 한다.
+ **속성**
  + DB를 구성하는 가장 작은 논리적 단위
  + 파일 구조에서의 데이터 항목 또는 데이터 필드
  + 속성은 개체의 특성을 기술
  + 속성의 수를 **디그리** 또는 **차수**라고 한다.
+ **도메인**
  + **하나의 속성이 취할 수 있는 같은 타입의 원자 값들의 집합**
    + set(속성)과 같은 느낌
  + 도메인은 실제 속성 값이 나타날 때 그 **값의 합법 여부**를 시스템이 검사하는데에도 이용된다.





### 4.3 릴레이션의 특징

+ 한 릴레이션에는 똑같은 튜플이 포함될 수 없다.
+ **튜플 사이에는 순서가 없다.**
+ 튜플들의 삽입, 삭제 등의 작업으로 인해 릴레이션은 시간에 따라 변한다.
+ **릴레이션 스키마를 구성하는 속성들 간의 순서는 중요하지 않다.**

+ 릴레이션을 구성하는 튜플을 유일하게 식별하기 위해 속성들의 부분집합을 키로 설정한다.

+ 속성의 값은 **논리적으로 더 이상 쪼갤 수 없는 원자값**만을 저장한다.







## 5. 관계형 데이터베이스의 제약 조건 - 키(key)

+ 제약 조건이란 데이터베이스에 저장되는 데이터의 **정확성을 보장**하기 위하여 **키를 이용하여 입력되는 데이터에 제한을 주는 것**으로 **개체 무결성 제약**, **참조 무결성 제약** 등이 해당된다.

### 5.1 키의 개념 및 종류

+ 키는 데이터베이스에서 조건에 만족하는 튜플을 찾거나 순서대로 정렬할 때 **튜플들을 서로 구분할 수 있는 기준이 되는 애트리뷰트**를 말한다.
+ 키의 종류에는 **후보키, 기본키, 대체키, 슈퍼키, 외래키** 등이 있다.





### 5.2 후보키

+ 후보키는 릴레이션을 구성하는 속성들 중에서 **튜플을 유일하게 식별하기 위해 사용하는 속성들의 부분집합**, 즉 **기본키로 사용할 수 있는 속성들**

+ 모든 릴레이션에는 반드시 하나 이상의 후보키가 존재

+ 후보키는 릴레이션에 있는 모든 튜플에 대하여 **유일성**과 **최소성**을 만족시켜야 한다.
  + 유일성
    + 하나의 키 값으로 하나의 튜플만을 유일하게 식별할 수 있어야 한다.
  + 최소성
    + 모든 레코드들을 유일하게 식별하는 데 **꼭 필요한 속성으로만 구성**되어야 한다.





### 5.3 기본키

+ 후보키 중에서 특별히 선정된 **주키**로 중복된 값을 가질 수 없다.
+ 한 릴레이션에서 특정 튜플을 유일하게 구별할 수 있는 속성
+ 후보키의 성질을 갖는다.(유일성, 최소성)
+ 기본키는 **NULL값을 가질 수 없다.**





### 5.4 대체키

+ 대체키는 후보가 둘 이상일 때 기본키를 제외한 나머지 후보키를 의미한다. (보조키라고도 한다)





### 5.5 슈퍼키

+ 슈퍼키는 한 릴레이션 내에 있는 속성들의 집합으로 구성된 키로서 릴레이션을 구성하는 모든 튜플들 중 슈퍼키로 구성된 속성의 집합과 동일한 값은 나타나지 않는다.
+ **슈퍼키는 유일성은 만족시키지만 최소성은 만족시키지 못한다.**





### 5.6 외래키

+ 외래키는 다른 릴레이션의 기본키를 참조하는 속성 또는 속성들의 집합을 의미한다.
+ 외래키는 참조되는 릴레이션의 기본키와 대응되어 **릴레이션 간에 참조 관계를 표현하는데 중요한 도구**이다.
+ 한 릴레이션에 속한 속성 A와 참조 릴레이션의 기본키인 B가 **동일한 도메인 상에서 정의되었을 때**의 속성 A를 외래키라고 한다.
+ 외래키로 지정되면 참조 릴레이션의 기본키에 없는 값은 입력할 수 없다.







## 6. 관계형 데이터베이스의 제약 조건 - 무결성

### 6.1 무결성(Integrity)의 개념 및 종류

+ 무결성이란 DB에 저장된 데이터 값과 그것이 표현하는 현실 세계의 실제 값이 일치하는 **정확성을 의미**한다.
+ 무결성 제약 조건은 DB에 들어 있는 데이터의 정확성을 보장하기 위해 **부정확한 자료가 DB 내에 저장되는 것을 방지하기 위한 제약 조건**을 말한다.
+ **개체 무결성, 도메인 무결성, 참조 무결성, 사용자 정의 무결성** 등이 있다.





### 6.2 개체 무결성

+ 기본 테이블의 **기본키를 구성하는 어떤 속성도 NULL값이나 중복값을 가질 수 없다는 규정**이다.





### 6.3 도메인 무결성

+ **주어진 속성 값이 정의된 도메인에 속한 값이어야 한다는 규정**





### 6.4 참조 무결성

+ 외래키 값은 **NULL이거나 참조 릴레이션의 기본키 값**과 동일해야 한다.
  + 즉, 참조할 수 없는 외래키 값을 가질 수 없다는 규정
+ 외캐리와 참조하려는 테이블의 기본키는 **도메인 속성 개수가 같아야 한다.**





### 6.5 사용자 정의 무결성

+ 속성 값들이 사용자가 정의한 제약 조건에 만족해야 한다는 규정





### 6.6 데이터 무결성 강화

+ **애플리케이션, 데이터베이스 트리거, 제약 조건**을 이용하여 강화
+ **애플리케이션**
  + **데이터 생성, 수정, 삭제 시 무결성 조건을 검증하는 코드**를 데이터를 조작하는 프로그램 내에 추가
  + 코드를 이용한 복잡한 규칙 등을 검토하는 무결성 검사는 DB수행하기 어려우므로 애플리케이션에서 수행

+ 데이터베이스 트리거
  + 트리거 이벤트에 무결성 조건을 실행하는 절차형 SQL을 추가

+ 제약 조건
  + DB에 제약 조건을 설정하여 무결성을 유지







## 7. 관계대수 및 관계해석

### 7.1 관계대수의 개요

+ 관계대수는 관계형 DB에서 **원하는 정보와 그 정보를 검색하기 위해서 어떻게 유도하는가**를 기술하는 **절차적인 언어**이다.
+ 릴레이션을 처리하기 위해 **연산자와 연산규칙을 제공하는 언어**로써 피연산자가 릴레이션이고 결과도 릴레이션이다.

+ 질의에 대한 해를 구하기 위해 수행해야 할 **연산의 순서를 명시**한다.
+ 순수 관계 연산자: Select, Project, Join, Division
+ 일반 집합 연산자: UNION(합집합), INTERSECTION(교집합), DIFFERENCE(차집합), CARTESIAN PRODUCT(교차곱)





### 7.2 Select

+ 릴레이션에 존재하는 튜플 중에서 **선택 조건을 만족하는 튜플의 부분집합을 구하여 새로운 릴레이션**을 만드는 연산

+ 릴레이션의 행에 해당하는 튜플을 구하는 것이므로 **수평 연산**이라고도 한다.
+ 연산자의 기호는 그리스 문자 시그마`σ`

+ 표기 형식: σ<조건>(R)
  + R은 릴레이션 이름
  + 예) σAvg>=90 (성적)





### 7.3 Project

+ 주어진 릴레이션에서 **속성 리스트에 제시된 속성 값만을 추출**해 새로운 릴레이션을 만드는 연산(**중복 제거**)

+ **수직 연산**
+ 연산자의 기호는 그리스 문자 파이`π`
+ 표기 형식: π<속성리스트>(R)
  + 예) πName, Avg (성적)





### 7.4 Join

+ **공통 속성을 중심으로 두 개의 릴레이션을 하나로 합쳐서** 새로운 릴레이션을 만드는 연산

+ Join의 결과로 만들어진 릴레이션의 차수는 **조인된 두 릴레이션의 차수를 합한 것**
+ Join의 결과는 교차곱을 수행한 다음에 Select를 수행한 것과 같다.
+ 연산자 기호는 `⋈`
+ 표기 형식: R ⋈ 키속성r=키속성s S
  + 예) 성적 ⋈ No=No 학적부	
    + 성적 릴레이션과 학적부 릴레이션을 'No'속성을 기준으로 합치시오
    + 이때, 성적.No와 학적부.No의 속성 2개가 생긴다.
      + **자연 조인을 하면 중복되는 속성을 하나만 표시한다.**





### 7.5 Division

+ Y ⊂ X인 두 개의 릴레이션 R(X)와 S(Y)가 있을 때, R의 속성이 S의 속성값을 모두 가진 튜플에서 S가 가진 속성을 제외한 속성만을 구하는 연산
+ 연산자 기호는 `÷`
+ 표기형식: R [속성r÷속성s] S
  + 속성r과 속성s는 동일 속성값을 가지는 속성이어야 한다.
  + **즉, 속성s의 값들을 가지는 튜플에서 속성r을 제외한 나머지 속성들로 새로운 튜플을 구해서 만든 릴레이션** (중복 제거)





### 7.6 일반 집합 연산자

+ 합병 조건을 만족해야만 한다.
  + 합병하려는 두 릴레이션 간에 **속성의 수가 같고**, **대응되는 속성별로 도메인이 같아야** 한다.

| 연산자 | 기능 및 수학적 표현           | 카디널리티                                               |
| ------ | ----------------------------- | -------------------------------------------------------- |
| 합집합 | ∪ 튜플의 합집합, 중복 제거    | 두 릴레이션의 카디널리티 합보다 작다.                    |
| 교집합 | ∩ 튜플의 교집합               | 두 릴레이션 중 카디널리티가 적은 릴레이션보다 크지 않다. |
| 차집합 | -  튜플의 차집합              | R-S일 때 R의 카디널리티보다 크지 않다.                   |
| 교차곱 | x 두 릴레이션의 튜플의 순서쌍 | 두 릴레이션의 카디널리티 곱과 같다. (차수는 합)          |





### 7.7 관계해석

+ 관계해석은 관계 데이터 모델의 제안자인 코드가 제안
+ 관계 데이터의 연산을 표현하는 방법으로, 원하는 정보를 정의할 때는 계산 수식을 사용
+ 원하는 정보가 무엇이라는 것만 정의하는 **비절차적 특성**
  + **관계대수는 절차적이다.**
+ **튜플 관계해석, 도메인 관계해석**
+ **질의어로 표현**







## 8. 정규화

### 8.1 정규화의 개요

+ 함수적 종속성 등의 **종속성 이론**을 이용하여 잘못 설계된 **관계형 스키마를 더 작은 속성의 세트로 쪼개어 바람직한 스키마로 만들어가는 과정**

+ 하나의 종속성이 하나의 릴레이션에 표현될 수 있도록 분해해가는 과정
+ 제1정규형, 제2정규형, 제3정규형, BCNF형, 제4정규형, 제5정규형
  + 차수가 높아질수록 만족시켜야 할 제약 조건이 늘어난다.
+ 정규화는 DB의 **논리적 설계 단계**에서 수행한다.
+ 정규화된 데이터 모델은 **일관성, 정확성, 단순성, 비중복성, 안정성 등을 보장**





### 8.2 정규화의 목적

+ **데이터 구조의 안정성 및 무결성을 유지**
+ 어떠한 릴레이션이라도 DB내에서 표현 가능하게 만든다.
+ 효율적인 검색 알고리즘을 생성할 수 있다.
+ 중복을 배제하여 **이상(Anomaly)의 발생 방지** 및 자료 저장 공간의 최소화





### 8.3 이상(Anomaly)의 개념 및 종류

+ 정규화를 거치지 않으면 DB 내에 **데이터들이 불필요하게 중복되어** 릴레이션 조작 시 예기치 못한 곤란한 현상이 발생하는데, 이를 이상이라 하며 **삽입 이상, 삭제 이상, 갱신 이상**이 있다.
+ **삽입 이상**
  + 릴레이션에 데이터를 삽입할 때 **의도와는 상관없이 원하지 않은 값들도 함께 삽입**되는 현상
+ **삭제 이상**
  + 릴레이션에서 한 튜플을 삭제할 때 **의도와는 상관없는 값들도 함께 삭제**되는 연쇄가 일어나는 현상
+ **갱신 이상**
  + 릴레이션에서 튜플에 있는 속성값을 갱신할 때 **일부 튜플의 정보만 갱신**되어 정보에 모순이 생기는 현상





### 8.4 정규화의 원칙

+ **정보의 무손실 표현**, 즉 하나의 스키마를 다른 스키마로 변환할 때 정보의 손실이 있어서는 안된다.
+ **분리의 원칙**, 즉 하나의 독립된 관계성은 하나의 독립된 릴레이션으로 분리시켜 표현해야 한다.
+ 데이터의 중복이 감소되어야 한다.





### 8.5

+ **1NF(제1정규형)**

  + 릴레이션에 속한 **모든 도메인이 원자값**만으로 되어 있는 정규형. 즉, **모든 속성 값이 원자값**

+ **2NF**

  + 릴레이션 R이 1NF이고, 기본키가 아닌 **모든 속성이 기본키에 대하여 완전 함수적 종속**을 만족하는 정규형

  + 함수적 종속은 데이터들이 어떤 기준값에 의해 종속되는 것
    + <수강>릴레이션이 (학번, 이름, 과목명)으로 되어 있을 때, '학번'이 결정되면 '과목명'에 상관없이 '학번'에는 항상 같은 '이름'이 대응된다. '학번'에 따라 '이름'이 결정될 때 '이름'을 '학번'에 함수 종속적이라고 하며 '학번' -> '이름'과 같이 쓴다.
    + 쉽게 말해, 기본키에 따라 항상 같은 데이터가 오는 것

+ **3NF**

  + 릴레이션 R이 2NF이고, 기본키가 아닌 **모든 속성이 기본키에 대해 이행적 종속을 만족하지 않는** 정규형
    + 이행적 종속: A -> B이고 B -> C일 때 A -> C를 만족하는 관계

  + 무손실 조인 또는 종속성 보존을 저해하지 않고도 항상 3NF설계를 얻을 수 있다.

+ **BCNF**

  + 릴레이션 R에서 **결정자가 모두 후보키인 정규형**
    + 결정자: 속성 간의 종속성을 규명할 때 기준이 되는 값. '학번' -> '이름'이라 할 때, '학번'이 결정자

+ **4NF**

  + 릴레이션 R에 **다치 종속** A ->> B가 성립하는 경우 **R의 모든 속성이 A에 함수적 종속 관계**를 만족하는 정규형
    + 다치 종속: A, B, C 3개의 속성을 가진 릴레이션 R에서 어떤 복합 속성 (A, C)에 대응하는 B값의 집합이 A값에만 종속되고 C값에는 무관하면 B는 A에 다치 종속이라 하고 A ->> B라고 표기

+ **5NF**
  + 릴레이션 R의 **모든 조인 종속이 R의 후보키를 통해서만 성립되는 정규형**

+ 외우는 방법 - 도부이결다조..