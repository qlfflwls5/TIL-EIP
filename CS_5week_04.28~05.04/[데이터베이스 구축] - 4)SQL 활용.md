# [데이터베이스 구축] - 4)SQL 활용







## 1. 프로시저

+ 프로시저란 **절차형 SQL을 활용하여 특정 기능을 수행하는 일종의 트랜잭션 언어**로, 호출을 통해 실행되어 **미리 저장해 놓은 SQL 작업을 수행**한다.
  + 절차형 SQL
    + C, JAVA 등의 프로그래밍 언어과 같이 연속적인 실행이나 분기, 반복 등의 제어가 가능한 SQL
+ 프로시저를 만들어 **DB에 저장**하면 여러 프로그램에서 호출하여 사용할 수 있다.
+ 프로시저는 DB에 저장되어 수행되기 때문에 **스토어드 프로시저**라고도 불린다.
+ 프로시저는 **시스템의 일일 마감 작업**, **일괄 작업** 등에 주로 사용

```
DECLARE(필수)
BEGIN(필수)
  CONTROL
  SQL
  EXCEPTION
  TRANSACTION
END(필수)
```

+ DECLARE: 프로시저의 명칭, 변수, 인수, 데이터 타입을 정의하는 선언부
+ BEGIN / END: 프로시저의 시작과 종료를 의미
+ CONTROL: 조건문 또는 반복문이 삽입되어 순차적으로 처리된다.
+ SQL: DML, DCL이 삽입되어 데이터 관리를 위한 조회, 추가, 삭제, 수정 작업을 수행
+ EXCEPTION: BEGIN ~ END 안의 구문을 실행 시 예외가 발생하면 이를 처리하는 방법을 정의
+ TRANSACTION: 수행된 데이터 작업들을 DB에 적용할지 취소할지를 결정하는 처리부

### 1.1 프로시저 생성

+ `CREATE PROCEDURE`명령어를 사용

```
CREATE [OR REPLACE] PROCEDURE 프로시저명(파라미터)
[지역변수 선언]
BEGIN
  프로시저 BODY;
END;
```

+ OR REPLACE: 선택적인 예약어. 동일한 프로시저 이름이 이미 존재하면 기존 것을 대체할 수 있다.
+ 파라미터: IN, OUT, INOUT, 매개변수명, 자료형
+ 프로시저 BODY: 프로시저의 코드를 기록하는 부분. 적어도 하나의 SQL문이 있어야 한다.





### 1.2 프로시저 실행

+ `EXECUTE` 명령어 또는 `CALL` 명렁어를 사용하며, `EXECUTE`는 `EXEC`으로 줄여 사용하기도 한다.

```
EXECUTE 프로시저명;
EXEC 프로시저명;
CALL 프로시저명;
```





### 1.3 프로시저 제거

+ `DROP PROCEDURE` 명령어 사용

```
DROP PROCEDURE emp_change_s;
```







## 2. 트리거

+ DB시스템에서 데이터의 사입, 갱신, 삭제 등의 이벤트가 발생할 때마다 관련 작업이 자동으로 수행되는 절차형 SQL
+ 트리거는 DB에 저장되며, **데이터 변경 및 무결성 유지, 로그 메시지 출력** 등의 목적으로 사용된다.
+ 트리거의 구문에는 **DCL을 사용할 수 없으며**, **DCL이 포함된 프로시저나 함수를 호출하는 경우도 오류**가 난다.

+ **트리거에 오류가 있는 경우 트리거가 처리하는 데이터에도 영향**을 미치므로 세심한 주의가 필요

### 2.1 트리거의 구성

+ 트리거는 선언, 이벤트, 시작, 종료로 구성되며, 시작과 종료 구문 사이에는 제어(CONTROL), SQL, 예외(EXCEPTION)가 포함된다.

```
DECLARE(필수)
EVENT(필수)
BEGIN(필수)
  CONTROL
  SQL
  EXCEPTION
END(필수)
```

+ EVENT: 트리거가 실행되는 조건을 명시





### 2.2 트리거의 생성

+ `CREATE TRIGGER`

```
CREATE [OR REPLACE] TRIGGER 트리거명 동작시기 동작 ON 테이블명
[REFERENCING NEW | OLD AS 테이블명]
[FOR EACH ROW [WHERE 조건식]]
BEGIN
  트리거 BODY;
END;
```

+ 동작시기: 트리거가 실행될 때를 지정한다. 종류에는 AFTER와 BEFORE가 있다.
  + **기준은 테이블이 변경된 시점이다.**
+ 동작: 트리거가 실행되게 할 작업의 종류를 지정한다. 종류에는 INSERT, DELETE, UPDATE가 있다.
+ NEW | OLD: 트리거가 적용될 테이블의 별칭을 지정
  + NEW: 추가되거나 수정에 참여할 튜플들의 집합을 의미
  + OLD: 수정되거나 삭제 전 대상이 되는 튜플들의 집합을 의미
+ FOR EACH ROW: 각 튜플마다 트리거를 적용한다는 의미

```
CREATE TRIGGER 학년정보_tri BEFORE INSERT ON 학생
REFERENCING NEW AS new_table
FOR EACH ROW
WHEN (new_table.학년 IS NULL)
  BEGIN
  	:new_table.학년 := '신입생';
  END;
```

+ REFERENCING ~ : 새로 추가될 튜플들의 집합 NEW의 별칭을 new_table로 명명한 것
+ NEW 또는 OLD로 지정된 테이블 이름 앞에는 콜론이 들어간다.
+ `A := B`는 A에 B를 치환하라는 의미이다.(NULL이면 NULL을 신입생으로 치환해라.)





### 2.3 트리거 제거

+ `DROP TRIGGER 트리거명;`

```
DROP TRIGGER 트리거명;
```







## 3. 사용자 정의 함수

+ 프로시저와 유사하게 SQL을 사용하여 일련의 작업을 연속적으로 처리하며, **종료 시 처리 결과를 단일값으로 반환하는 절차형 SQL**
+ 사용자 정의 함수는 DB에 저장되어 SELECT, INSERT, DELETE, UPDATE등 DML문의 호출에 의해 실행된다.

+ 예약어 RETURN을 통해 값을 반환
+ **사용자 정의 함수는 테이블 조작은 할 수 없고 SELECT를 통한 조회만 할 수 있다.**
+ **사용자 정의 함수는 프로시저를 호출하여 사용할 수 없다.**
+ SUM(), AVG() 등의 내장 함수처럼 DML문에서 반환값을 활용하기 위한 용도로 사용된다.

### 3.1 사용자 정의 함수의 구성

```
DECLARE(필수)
BEGIN(필수)
  CONTROL
  SQL
  EXCEPTION
  RETURN(필수)
END(필수)
```

+ SQL: **SELECT문이 삽입되어 데이터 조회 작업을 수행**
+ RETURN: 호출 프로그램에 반환할 값이나 변수를 정의





### 3.2 사용자 정의 함수 생성

+ `CREATE FUNCTION`

```
CREATE [OR REPLACE] FUNCTION 사용자 정의 함수명(파라미터)
[지역변수 선언]
BEGIN
  사용자 정의 함수 BODY;
  RETURN 반환값;
END;
```

+ 파라미터: IN, 매개변수명, 자료형이 올 수 있다.

```
CREATE FUNCTION GET_S_성별(i_성별코드 IN INT)
RETURN VARCHAR2
IS
BRGIN
  IF i_성별코드 = 1 THEN
  	RETURN '남자';
  ELSE
  	RETURN '여자';
  END IF;
END;
```

+ RETURN VARCHAR2: 블록에서 리턴할 데이터의 자료형을 정의
+ IS: 변수 선언을 위해 사용하는 예약어로, 변수를 사용하지 않으므로 예약어만 입력한다.





### 3.3 사용자 정의 함수 실행

+ 사용자 정의 함수는 DML에서 속성명이나 값이 놓일 자리를 대체하여 사용

```
SELECT 사용자 정의 함수명 FROM 테이블명;
INSERT INTO 테이블명(속성명) VALUES (사용자 정의 함수명);
DELETE FROM 테이블명 WHERE 속성명 = 사용자 정의 함수명;
UPDATE 테이블 SET 속성명 = 사용자 정의 함수명;
```





### 3.4 사용자 정의 함수 제거

+ `DROP FUNCTION 사용자 정의 함수명;`







## 4. DBMS 접속 기술

+ DBMS 접속은 사용자가 데이터를 사용하기 위해 응용 시스템을 이용하여 DBMS에 접근하는 것을 의미
+ 응용 시스템은 사용자로부터 **매개 변수**를 전달받아 **SQL을 실행**하고 **DBMS로부터 전달받은 결과**를 사용자에게 전달하는 매개체 역할을 수행

+ 인터넷을 통해 구동되는 웹 응용 프로그램은 **웹 응용 시스템**을 통해 DBMS에 접근
+ 웹 응용 시스템은 **웹 서버**와 **웹 애플리케이션 서버(WAS)**로 구성되며, 서버의 규모가 작은 경우 둘을 통합하여 하나의 서버로 운용할 수 있다.

### 4.1 DBMS 접속 기술

+ DBMS에 접근하기 위해 사용하는 API 또는 API의 사용을 편리하게 도와주는 프레임워크를 의미한다.
  + API
    + 응용 프로그램 개발 시 운영체제나 DBMS 등을 이용할 수 있도록 규칙 등에 대해 정의해 놓은 인터페이스
+ **JDBC**
  + JAVA 언어로 다양한 종류의 DB에 접속하고 SQL문을 수행할 때 사용되는 표준 API
  + JAVA SE에 포함되어 있다.
  + 접속하려는 DBMS에 대한 드라이버가 필요하다.
+ **ODBC**
  + DB에 접근하기 위한 표준 개방형 API로, 개발 언어에 관계없이 사용할 수 있다.
  + 프로그램 내 ODBC 문장을 사용해 액세스, DBase, DB2, Excel 등 다양한 DB에 접근 가능
+ **MyBatis**
  + JDBC 코드를 단순화하여 사용할 수 있는 **SQL Mapping 기반 오픈 소스 접속 프레임워크**
  + SQL을 분리하여 XML 파일을 만들고, Mapping을 통해 SQL을 실행한다.
  + SQL을 거의 그대로 사용할 수 있어 많이 사용된다.





### 4.2 동적 SQL

+ **개발 언어에 삽입되는 SQL 코드를 문자열 변수에 넣어 처리하는 것**으로, 조건에 따라 SQL 구문을 동적으로 변경하여 처리할 수 있다.
+ 동적 SQL은 응용 프로그램 수행 시 SQL이 변형될 수 있으므로 **프리컴파일 할 때 구문 분석, 접근 권한 확인 등을 할 수 없다.**

+ 값이 입력되지 않을 경우 사용하는 **NVL 함수를 사용할 필요가 없다.**







## 5. SQL 테스트

+ **단문 SQL**은 코드를 직접 실행한 후 결과를 확인하는 것으로 간단히 테스트 가능
+ **절차형 SQL**은 테스트 전에 **생성을 통해 구문 오류나 참조 오류의 존재 여부를 확인**
  + 정상적으로 생성된 절차형 SQL은 **디버깅을 통해 로직을 검증**하고, **결과를 통해 최종적 확인**

### 5.1 단문 SQL 테스트

+ **DESCRIBE 명령어를 이용하면 DDL로 작성된 테이블**이나 뷰의 속성, 자료형, 옵션들을 확인 가능

  + ```
    DESC [개체명];
    ```

+ **DML**로 변경한 데이터는 **SELECT문**으로 정상적인 변경 여부 확인

+ **DCL**로 설정된 사용자 권한은 **사용자 권한 정보가 저장된 테이블을 SELECT로 조회**하거나, **SHOW 명령어**로 확인 가능





### 5.2 절차형 SQL 테스트

+ 디버깅을 통해 기능의 적합성 여부를 검증, 실행을 통해 결과를 확인
  + `SHOW ERRORS`
+ **DB에 변화를 줄 수 있는 SQL문은 주석으로 처리하고, 출력문을 이용하여 화면에 출력하여 확인**







## 6. ORM(Object-Relational Mapping)

+ **ORM은 객체지향 프로그래밍의 객체와 관계형 데이터베이스의 데이터를 연결하는 기술을 의미한다.**
+ ORM은 객체지향 프로그래밍에서 사용할 수 있는 **가상의 객체지향 데이터베이스를 만들어** 프로그래밍 코드와 데이터를 연결
+ ORM으로 생성된 **가상의 객체지향 데이터베이스는 프로그래밍 코드 또는 데이터베이스와 독립적**이므로 **재사용 및 유지보수가 용이**

+ ORM은 SQL 코드를 직접 입력하지 않고 선언문이나 할당 같은 부수적인 코드가 생략되기 때문에 직관적이고 간단하게 데이터를 조작 가능

+ 한계
  + ORM은 프레임워크가 자동적으로 SQL을 작성하기 떄문에 의도대로 SQL이 작성되었는지 확인할 필요가 있다.
  + 객체지향적인 사용을 고려하고 설계된 DB가 아닌 경우 프로젝트가 크고 복잡해질수록 ORM기술을 적용하기 어려워진다.
  + 기존의 기업들은 ORM을 고려하지 않은 DB를 사용하고 있기 때문에 ORM에 맞게 변환하려면 힘들다.