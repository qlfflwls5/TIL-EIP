# [프로그래밍 언어 활용] - 3)응용SW 기초기술 활용







## 5. 주기억장치 할당 기법

+ 주기억장치 할당 기법은 프로그램이나 데이터를 실행시키기 위해 주기억장치에 어떻게 할당할 것인지에 대한 내용, 연속 할당 기법과 분산 할당 기법으로 분류
+ 연속 할당 기법
  + 프로그램을 주기억장치에 연속으로 할당하는 기법, **단일 분할 할당 기법**과 **다중 분할 할당 기법**
  + 단일 분할 할당 기법 : 오버레이, 스와핑
  + 다중 분할 할당 기법 : 고정 분할 할당 기법, 동적 분할 할당 기법
+ 분산 할당 기법
  + 프로그램을 특정 단위의 조각으로 나누어 주기억장치 내에 분산하여 할당하는 기법으로, **페이징 기법**과 **세그먼테이션 기법**으로 나눔

### 5.1 단일 분할 할당 기법

+ 주기억장치를 운영체제 영역과 **사용자 영역**으로 나누어 한 순간에는 오직 한 명의 사용자만이 주기억장치의 사용자 영역을 사용하는 기법
+ 가장 단순한 기법으로 초기 운영체제에서 많이 사용
+ 운영체제를 보호하고, 프로그램이 사용자 영역만을 사용하기 위해 운영체제 영역과 사용자 영역을 구분하는 경계 레지스터가 사용된다.
  + **경계 레지스터**
    + 사용자 영역이 시작되는 주소를 기억해 사용자 프로그램이 운영체제 영역에 접근하지 못하도록 함
+ 프로그램의 크기가 작을 경우 사용자 영역이 낭비될 수 있다.
+ 초기에는 주기억장치보다 큰 사용자 프로그램은 실행할 수 없었으나 오버레이 기법을 사용하면서 문제 해결

#### 5.1.1 오버레이 기법

+ 주기억장치보다 큰 사용자 프로그램을 실행하기 위한 기법
+ 보조기억장치에 저장된 하나의 프로그램을 여러 개의 조각으로 분할한 후 필요한 조각을 차례대로 주기억장치에 적재하여 프로그램 실행
+ 프로그램이 실행되면서 주기억장치의 공간이 부족하면 주기억장치에 적재된 프로그램 조각 중 불필요한 조각이 위치한 장소에 새로운 프로그램 조각을 중첩(Overlay)하여 적재

<br/>

#### 5.1.2 스와핑 기법

+ 하나의 프로그램 전체를 주기억장치에 할당하여 사용하다 필요에 따라 다른 프로그램과 교체하는 기법
+ 보조기억장치에서 프로그램이 들어오면 Swap In, 보조기억장치로 이동되면 Swap Out이라고 한다.
+ 가상기억장치의 페이징 기법으로 발전되었다.

<br/>

<br/>

### 5.2 다중 분할 할당 기법

#### 5.2.1 고정 분할 할당 기법(정적 할당 기법)

+ 프로그램을 할당하기 전에 운영체제가 주기억장치의 사용자 영역을 여러 개의 고정된 크기로 분할하고 준비상태 큐에서 준비중인 프로그램을 각 영역에 할당하여 수행하는 기법

+ 프로그램을 실행하려면 프로그램 전체가 주기억장치에 위치해야 한다.
+ 프로그램이 분할된 영역보다 커서 영역 안에 들어갈 수 없는 경우가 발생할 수 있다.
+ 일정한 크기의 분할 영역에 다양한 크기의 프로그램이 할당되므로 내부 단편화 및 외부 단편화가 발생해 주기억장치 낭비가 많다.
+ 실행될 프로그램의 크기를 미리 알고 있어야 한다.

<br/>

#### 5.2.2 가변 분할 할당 기법(동적 할당 기법)

+ 단편화를 줄이기 위한 방법으로, 미리 주기억장치를 분할해 놓는 것이 아니라 프로그램을 주기억장치에 적재하면서 필요한 만큼의 크기로 영역을 분할하는 기법
+ 주기억장치를 효율적으로 사용할 수 있으며, 다중 프로그래밍의 정도를 높일 수 있다.
+ 단편화를 상당 부분 해결할 수 있지만 영역과 영역 사이에 단편화가 발생할 수 있다.

<br/>

<br/>

## 6. 가상기억장치 구현 기법 / 페이지 교체 알고리즘(중요)

### 6.1 가상기억장치의 개요

+ 가상 기억장치는 보조기억장치(하드디스크)의 일부를 주기억장치처럼 사용하는 것으로, 용량이 작은 주기억장치를 마치 큰 용량을 가진 것처럼 사용하는 기법
+ **프로그램을 여러 개의 작은 블록 단위로 나누어서 가상기억장치에 보관해 놓고, 프로그램 실행 시 요구되는 블록만 주기억장치에 불연속적으로 할당하여 처리한다.**
  + 블록
    + 보조기억장치와 주기억장치 간에 전송되는 데이터의 최소 단위

+ 주기억장치의 용량보다 큰 프로그램을 실행하기 위해 사용된다.
+ 가상기억장치에 저장된 프로그램을 실행하려면 가상기억장치의 주소를 주기억장치의 주소로 바꾸는 주소 변환 작업이 필요하다.
  + 논리적인 가상 주소가 물리적인 실기억주소로 변환되어야 함
  + **인위적 연속성** : 가상주소 공간 상의 연속적인 주소가 실저장장치에서 연속적일 필요가 없다.
+ 블록 단위로 나누어 사용하므로 연속 할당 방식에서 발생할 수 있는 단편화를 해결

+ 페이징 기법과 세그먼테이션 기법

<br/>

<br/>

### 6.2 페이징 기법

+ 가상기억장치에 보관되어 있는 프로그램과 주기억장치의 영역을 동일한 크기로 나눈 후 나눠진 프로그램(**페이지**)을 동일하게 나눠진 주기억장치의 영역(**페이지 프레임**)에 적재시켜 실행하는 기법
+ 외부 단편화는 발생하지 않으나 내부 단편화는 발생할 수 있다.
  + 페이지 크기가 4KB이고 프로그램이 17KB라면 마지막 페이지는 1KB 용량이 되어 3KB의 내부 단편화
+ 주소 변환을 위해서 페이지의 위치 정보를 가지고 있는 페이지 맵 테이블이 필요하다.
  + 이로 인해 비용이 증가되고 처리 속도가 감소된다.

<br/>

<br/>

### 6.3 세그먼테이션 기법

+ 세그먼테이션 기법은 가상기억장치에 보관되어 있는 프로그램을 다양한 크기의 논리적인 단위로 나눈 후 주기억장치에 적재시켜 실행시키는 기법
+ 프로그램을 배열이나 함수 등과 같은 논리적인 크기로 나눈 단위를 세그먼트라고 하며, 각 세그먼트는 고유한 이름과 크기를 갖는다.
+ 기억장치의 사용자 관점을 보존
+ 이 기법을 사용하는 궁극적인 이유는 기억공간을 절약하기 위해서이다.
+ 세그먼트 맵 테이블이 필요하다.
+ 세그먼트가 주기억장치에 적재될 때 다른 세그먼트에게 할당된 영역을 침범할 수 없으며, 이를 위해 **기억장치 보호키**가 필요하다.
+ 내부 단편화는 발생하지 않으나 외부 단편화가 발생할 수 있다.

#### 6.3.1 세그먼테이션 기법의 일반적인 주소 변환

+ 주소 형식에 따른 주소와 세그먼트 맵 테이블의 구성

  + 가상주소는 세그먼트 번호를 나타내는 s와 세그먼트 내에 실제 내용이 위치하고 있는 곳까지의 거리를 나타내는 변위값 d로 구성된다.

    가상주소 형식 : s | d

  + 실기억주소는 완전주소 형태를 사용하며 이는 세그먼트의 기준번지와 변위값을 더함으로써 얻을 수 있다.

    실기억주소 형식 : 세그먼트 기준번지 + 변위값

  + 세그먼트 맵 테이블은 세그먼트 번호 s와 세그먼트의 크기 L(한계번지), 주기억장치 상의 기준번지(시작주소) b로 구성된다.

+ 주소 변환 순서

  + 세그먼트 맵 테이블 : s | L | b
  + 가상주소의 세그먼트 번호로 세그먼트 맵 테이블에서 해당 세그먼트의 기준번지와 세그먼트 크기를 구함
    + 세그먼트 번호는 세그먼트 맵 테이블에 대한 색인으로	 사용
  + 가상주소의 변위값과 크기를 비교
  + 변위값이 작거나 같으면 기준번지와 변위값을 더하여 실기억주소를 만들어 주기억장치를 액세스
  + 변위값이 크면 다른 영역을 침범하게 되므로 실행 권한을 운영체제에게 넘기고 트랩을 발생시킨다.(변위값이 크다는 것은 현재 찾는 세그먼트의 위치가 해당 세그먼트의 크기를 초과하였다는 것)

<br/>

<br/>

### 6.4 페이지 교체 알고리즘

+ 페이지 교체 알고리즘은 페이지 부재가 발생했을 때 가상기억장치의 필요한 페이지를 주기억장치에 적재해야 하는데, 이때 주기억장치의 모든 페이지 프레임이 사용중이면 어떤 페이지 프레임을 선택하여 교체할 것인지를 결정하는 기법
  + **페이지 부재**
    + CPU가 액세스한 가상 페이지가 주기억장치에 없는 경우. 디스크에서 주기억장치로 가져와야 한다.
+ OPT, FIFO, LRU, LFU, NUR, SCR
+ OPT(최적 교체)
  + 앞으로 가장 오랫동안 사용하지 않은 페이지를 교체하는 기법
+ FIFO(선입선출)
  + 가장 먼저 들어와서 가장 오래 있었던 페이지를 교체

+ LRU(Least Recently Used)
  + 최근에 가장 오랫동안 사용하지 않은 페이지를 교체
  + 각 페이지마다 계수기(Counter)나 스택(Stack)을 두어 현 시점에서 가장 오랫동안 사용하지 않은 페이지를 교체
+ LFU(Least Frequently Used)
  + 사용 빈도가 가장 적은 페이지를 교체
+ NUR(Not Used Recently)
  + LRU와 비슷한 알고리즘으로 최근에 사용하지 않은 페이지를 교체
  + 참조 비트와 변형 비트를 통해서 교체 순서 결정

+ SCR(2차 기회 교체)
  + 가장 오랫동안 주기억장치에 있던 페이지 중 자주 사용되는 페이지의 교체를 방지하기 위한 것
  + FIFO의 단점 보완

<br/>

<br/>

<br/>

## 7.  가상기억장치 기타 관리 사항

### 7.1 페이지 크기

+ 페이지 크기가 작으면
  + 단편화 감소, 한 개의 페이지를 주기억장치로 이동하는 시간 감소
  + 불필요한 내용이 주기억장치에 적재될 확률이 적으므로 효율적인 워킹 셋 유지
  + Locality에 더 일치할 수 있기 때문에 기억장치 효율이 높아짐
  + 페이지 정보를 갖는 **페이지 맵 테이블의 크기가 커지고 매핑 속도가 느려짐**
  + 디스크 접근 횟수가 많아져서 전체적인 입출력 시간이 늘어남
+ 페이지 크기가 크면
  + 페이지 맵 테이블의 크기는 작아지고 매핑 속도가 빨라짐
  + 단편화가 증가, 한 페이지를 옮기는 시간 증가

<br/>

<br/>

### 7.2 Locality

+ 프로세스가 실행되는 동안 주기억장치를 참조할 때 일부 페이지만 집중적으로 참조하는 성질이 있다.
+ 스래싱을 방지하기 위한 워킹 셋 이론의 기반
+ 데닝(Denning)에 의해 구역성의 개념이 증명되었고, 캐시 메모리 시스템의 이론적 근거가 됨
+ **시간 구역성**
  + 프로세스가 실행되면서 하나의 페이지를 일정 시간 동안 집중적으로 액세스하는 현상
  + Loop, 스택, 부 프로그램(서브 루틴), Counting, 집계 등
+ **공간 구역성**
  + 프로세스 실행 시 일정 위치의 페이지를 집중적으로 액세스하는 현상
  + 어느 하나의 페이지를 참조하면 그 근처의 페이지를 계속 참조할 가능성이 높음
  + 배열 순회, 순차적 코드의 실행 등

<br/>

<br/>

### 7.3 워킹 셋

+ 프로세스가 일정 시간 동안 자주 참조하는 페이지의 집합
+ 자주 참조되는 워킹 셋을 주기억장치에 상주시킴으로써 페이지 부재 및 페이지 교체 현상이 줄어들어 프로세스의 기억장치 사용이 안정된다.
+ 시간이 지남에 따라 알아서 변경된다.

<br/>

<br/>

### 7.4 프리페이징

+ 처음의 과도한 페이지 부재를 막기 위해 필요할 것 같은 모든 페이지를 한꺼번에 페이즈 프레임에 적재하는 기법

<br/>

<br/>

### 7.5 스래싱

+ 프로세스의 처리 시간보다 페이지 교체에 소요되는 시간이 더 많아지는 현상
+ 다중 프로그래밍 정도가 높아짐에 따라 특정 시점 이후부터 스래싱이 나타나고 CPU 이용률이 급격히 감소
+ 방지 방법
  + 다중 프로그래밍의 정도를 적정 수준으로 유지
  + 페이지 부재 빈도를 조절하여 사용
  + 워킹 셋 유지
  + 부족한 자원 증설, 일부 프로세스 중단

<br/>

<br/>

<br/>

## 8. 프로세스의 개요(중요)

### 8.1 프로세스의 정의

+ 프로세서(처리기, CPU)에 의해 처리되는 사용자 프로그램, 시스템 프로그램, 즉 실행중인 프로그램을 의미하며 작업, 태스크라고도 한다.
+ 실기억장치에 저장된 프로그램, 프로시저가 활동 중인 것, 비동기적 행위를 일으키는 주체, 운영체제가 관리하는 실행 단위
  + 프로시저
    + 한 프로그램은 여러 개의 작은 프로그램으로 분할될 수 있는데, 이를 프로시저, 부 프로그램이라 한다.

<br/>

<br/>

### 8.2 PCB(Process Control Block) 프로세스 제어 블록

+ 운영체제가 프로세스에 대한 중요한 정보를 저장해 놓는 곳
+ 각 프로세스가 생성될 때마다 고유의 PCB가 생성되고, 프로세스가 완료되면 PCB는 제거된다.
+ 정보들
  + 프로세스의 현재 상태 : 준비, 대기, 실행 등
  + 포인터 : 부모 프로세스에 대한 포인터, 자식 프로세스에 대한 포인터, 프로세스가 위치한 메모리에 대한 포인터, 할당된 자원에 대한 포인터
  + 프로세스 고유 식별자 : 프로세스를 구분할 수 있는 고유의 번호
  + 스케줄링 및 프로세스의 우선순위
  + CPU 레지스터 정보 : 누산기, 인덱스 레지스터, 범용 레지스터, 프로그램 카운터 등에 대한 정보
  + 주기억장치 관리 정보 : 기준 레지스터, 페이지 테이블에 대한 정보
  + 입출력 상태 정보
  + 계정 정보 : CPU 사용 시간, 실제 사용 시간, 한정된 시간

<br/>

<br/>

### 8.3 프로세스 상태 전이

+ 프로세스가 시스템 내에 존재하는 동안 프로세스의 상태가 변하는 것을 의미

  ![프로세스 관리](https://media.vlpt.us/images/csk917work/post/d4b5e4a9-b8dc-43ef-be94-dc832950f898/image.png)

+ 주요 세 가지 상태는 준비, 실행, 대기
+ 제출
  + 작업을 처리하기 위해 사용자가 작업을 시스템에 제출한 상태
+ 접수
  + 제출된 작업이 스풀 공간인 디스크의 할당 위치에 저장된 상태
+ 준비
  + 프로세스가 프로세서를 할당받기 위해 기다리고 있는 상태
  + 프로세스는 준비상태 큐에서 실행을 준비하고 있다.
  + 접수 상태에서 준비 상태로의 전이는 Job 스케줄러에 의해 수행된다.

+ 실행
  + 준비상태 큐에 있는 프로세스가 프로세서를 할당받아 실행되는 상태
  + 프로세스 수행이 완료되기 전에 프로세스에게 주어진 프로세서 할당 시간이 종료되면 프로세스는 준비 상태로 전이된다.
  + 실행중인 프로세스에 입출력 처리가 필요하면 실행중인 프로세스는 대기 상태로 전이된다.
  + 준비 상태에서 실행 상태로의 전이는 CPU(프로세서) 스케줄러에 의해 수행된다.
+ 대기, 보류, 블록
  + 프로세스에 입출력 처리가 필요하면 현재 실행중인 프로세스가 중단되고, 입출력 처리가 완료될 때까지 대기하고 있는 상태
+ 종료
  + 프로세스의 실행이 끝나고 프로세스 할당이 해제된 상태

+ Dispatch, Wake up, Spooling

<br/>

<br/>

### 8.4 스레드

+ 프로세스 내에서의 작업 단위로서 시스템의 여러 자원을 할당받아 실행하는 프로그램의 단위
+ 하나의 프로세스에 하나의 스레드가 존재하는 경우에는 단일 스레드, 하나 이상의 스레드가 존재하는 경우에는 다중 스레드라고 한다.
+ 프로세스의 일부 특성을 갖고 있기 때문에 경량 프로세스라고도 한다.
+ 스레드 기반 시스템에서 스레드는 **독립적인 스케줄링의 최소 단위**로서 프로세스의 역할을 담당한다.
+ **동일 프로세스 환경에서 서로 독립적인 다중 수행이 가능하다.**
+ 분류
  + 사용자 수준의 스레드
    + 사용자가 만든 라이브러리를 사용하여 스레드를 운용
    + 속도를 빠르지만 구현이 어렵다.
  + 커널 수준의 스레드
    + 운영체제의 커널에 의해 스레드를 운용
    + 구현이 쉽지만 속도가 느리다.

+ 스레드 사용의 장점
  + 하나의 프로세스를 여러 개의 스레드로 생성하여 **병행성**을 증진시킬 수 있다.
  + 하드웨어, 운영체제의 성능과 응용 프로그램의 처리율을 향상시킬 수 있다.
  + 응용 프로그램의 응답 시간을 단축시킬 수 있다.
  + **실행 환경을 공유시켜 기억장소의 낭비가 줄어든다.**
  + **프로세스들 간의 통신이 향상**된다.
  + **스레드는 공통적으로 접근 가능한 기억장치를 통해 효율적으로 통신**한다.

