# [소프트웨어 개발] - 1)데이터 입출력 구현







## 1. 자료 구조

### 1.1 자료 구조의 분류

+ 선형 구조
  + 배열(Array)
  + 선형 리스트(Linear List)
    + 연속 리스트(Contiguous List)
    + 연결 리스트(Linked List)
  + 스택(Stack)
  + 큐(Queue)
  + 데크(Deque)
+ 비선형 구조
  + 트리(Tree)
  + 그래프(Graph)





### 1.2 배열

+ **동일한 자료형의 데이터**들이 **같은 크기로 나열**되어 **순서**를 갖고 있는 집합이다.
+ **정적인 자료 구조**로 **기억장소의 추가가 어렵고**, 데이터 **삭제 시** 데이터가 저장되어 있던 **기억장소는 빈 공간으로 남아있어 메모리의 낭비가 발생**한다.

+ **첨자**`[]`를 이용하여 데이터에 접근
  + 사용한 첨자의 개수에 따라 n차원 배열이라고 부른다.
+ 반복적인 데이터 처리 작업에 적합한 구조
+ **데이터마다 동일한 이름의 변수를 사용**하여 처리가 간편하다.





### 1.3 선형 리스트

+ 일정한 순서에 의해 나열된 자료 구조
+ 배열을 이용하는 연속 리스트와 포인터를 이용하는 연결 리스트로 구분된다.
  + 포인터는 현재의 위치에서 다음 노드의 위치를 알려주는 요소
+ **연속 리스트**
  + 배열과 같이 연속되는 기억장소에 저장되는 자료 구조
  + 연속으로 배정받으므로 **기억장소 이용 효율은 밀도가 1로서 가장 좋다**
  + 중간에 데이터를 삽입하기 위해서는 연속된 빈 공간이 있어야 하며, 삽입 삭제 시 자료의 이동이 필요하다.
+ **연결 리스트**
  + 자료들을 임의의 기억공간에 기억시키되, 자료 항목의 순서에 따라 노드의 포인터 부분을 이용해 서로 연결시킨 자료 구조. **순차적인 선형 구조가 아니다.**
    + **노드는 Data부분과 Link부분으로 구성된 기억공간**
  + 노드의 삽입, 삭제가 용이하다.
  + 링크 부분이 필요하므로 기억장소 이용 효율은 좋지 않다.
  + 포인터를 찾는 시간 때문에 접근 속도가 느리다.





### 1.4 스택

+ **리스트의 한쪽 끝으로만 자료의 삽입, 삭제 작업**이 이루어지는 자료 구조이다.
+ **후입선출(LIFO)**의 방식으로 자료를 처리한다.
+ 모든 기억 공간이 꽉 차있는 상태에서 데이터가 삽입되면 **오버플로우**가 발생하며, 더 이상 삭제할 데이터가 없는 상태에서 삭제하면 **언더플로우**가 발생한다.
+ TOP
  + 스택으로 할당된 기억 공간에 가장 마지막으로 삽입된 자료가 기억된 위치를 가리키는 요소
+ BOTTOM
  + 스택의 가장 밑바닥





### 1.5 큐

+ **리스트의 한쪽에는 삽입 작업**이 이루어지고 **다른 한쪽에서는 삭제 작업**이 이루어지도록 구성한 자료 구조

+ **선입선출(FIFO)**의 방식으로 자료를 처리한다.
+ 큐는 시작과 끝을 표시하는 두 개의 포인터가 있다.
+ 프런트 포인터
  + 가장 먼저 삽입된 자료의 기억 공간을 가리키는 포인터로, 삭제 작업을 할 때 사용
+ 리어 포인터
  + 가장 마지막에 삽입된 자료가 위치한 기억 공간을 가리키는 포인터로, 삽입 작업을 할 때 사용
+ **큐는 운영체제의 작업 스케줄링에 사용한다.**





### 1.6 그래프

+ 그래프 G는 정점 V(Vertex)와 간선 E(Edge)의 두 집합으로 이루어진다.
+ 간선의 방향성 유무에 따라 방향 그래프와 무방향 그래프로 구분된다.
+ 통신망, 교통망, 이항관계, 연립방정식, 유기화학 구조식, 무향선분 해법 등에 응용된다.
+ 트리는 사이클이 없는 그래프이다.
+ n개의 정점으로 그래프에서
  + 무방향 그래프라면 최대 간선 수는 n(n-1)/2
  + 방향 그래프라면 최대 간선 수는 n(n-1)





## 2. 트리

### 2.1 트리의 개요

+ 정점(Node, 노드)과 선분(Branch, 가지)을 이용하여 사이클을 이루지 않도록 구성한 그래프의 특수한 형태이다.
+ 트리는 하나의 기억 공간을 노드라고 하며, 노드와 노드를 연결하는 선을 링크라고 한다.
+ 트리는 가족의 계보, 조직도 등을 표현하기에 적합하다.
+ 레벨
  + 루트 노드가 레벨1이다.
+ 노드
  + 트리의 기본 요소로서 자료 항목과 다른 항목에 대한 가지를 합친 것
+ 루트 노드
+ 디그리
  + 각 노드에서 뻗어 나온 가지의 수(**서브트리 수**)
+ 단말 노드(리프 노드)
+ 자식 노드
  + 어떤 노드에 연결된 다음 레벨의 노드들
+ 부모 노드
  + 어떤 노드에 연결된 이전 레벨의 노드들
+ 형제 노드
  + 동일한 부모를 갖는 노드들
+ 트리의 디그리
  + **노드들의 디그리 중에서 가장 많은 수**





### 2.2 트리의 운행법

+ Preorder(전위순회)
  + root - left - right
+ Inorder(중위순회)
  + left - root - right
+ Postorder(후위순회)
  + left - right - root





### 2.3 수식의 표기법

+ 산술식을 계산하기 위해 기억공간에 기억시키는 방법으로 이진 트리를 많이 사용한다.
+ 전위 표기법(Prefix)
  + 연산자 - left - right
+ 중위 표기법(Infix)
  + left - 연산자 - right
+ 후위 표기법(Postfix)
  + left - right - 연산자

+ Postfix나 Prefix는 스택을 이용하여 처리하므로 Infix는 Postfix나 Prefix로 바꾸어 처리한다.

#### 2.3.1 Infix 표기를 Prefix로 변환하기

1. 연산 우선순위에 따라 괄호로 묶는다.
2. 연산자를 해당 괄호의 앞(왼쪽)으로 옮긴다.
   + `x = (((A / B) * (C + D)) + E))`라면
     + `= (x + ( * ( / (AB) + (CD)) E ))`
3. 필요없는 괄호를 제거한다.
   + `=x+*/AB+CDE`



#### 2.3.2 Infix 표기를 Postfix로 변환하기

1. 연산 우선순위에 따라 괄호로 묶는다.
2. 연산자를 해당 괄호의 뒤(오른쪽)으로 옮긴다.
   + `(x(((AB) / (CD) + ) * E) + ) =`
3. 필요없는 괄호를 제거한다.
   + `xAB/CD+*E+=`



#### 2.3.3 Postfix를 Infix로 바꾸기

+ Postfix는 Infix 표기법에서 연산자를 해당 피연산자 두 개의 뒤로 이동한 것. 다시 가운데로 옮기면 됨

1. 인접한 피연산자 두 개와 오른쪽의 연산자를 괄호로 묶는다.
   + `ABC-/DEF+*+`라면
     + `((A(BC-)/)(D(EF+)*)+)`
2. 연산자를 해당 피연산자의 가운데로 이동시킨다.
   + `((A/(B-C)) + (D*(E+F)))`
3. 괄호를 제거한다.



#### 2.3.4 Prefix를 Infix로 바꾸기

1. 인접한 피연산자 두 개와 왼쪽의 연산자를 괄호로 묶는다.
2. 연산자를 해당 피연산자 사이로 이동시킨다.
3. 괄호를 제거한다.







## 3.  정렬

### 3.1 삽입 정렬(Insertion Sort)

+ 가장 간단한 정렬 방식으로 이미 순서화된 파일에 새로운 하나의 레코드를 순서에 맞게 삽입시켜 정렬한다.
+ 두 번째 키와 첫 번째 키를 비교해 순서대로 나열(1회전)하고, 이어서 세 번째 키를 첫 번째, 두 번째 키와 비교해 순서대로 나열(2회전)하고, 계속해서 n번째 키를 앞의 n-1개의 키와 비교하여 알맞은 순서에 삽입하여 정렬하는 방식이다.
+ 평균과 최악 모두 수행 시간 복잡도는 O(n^2)이다.





### 3.2 쉘 정렬(Shell sort)

+ 삽입 정렬을 확장한 개념이다.
+ 입력 파일을 어떤 매개변수(h)의 값으로 서브 파일을 구성하고, 각 서브파일을 Insertion 정렬 방식으로 순서 배열하는 과정을 반복하는 정렬방식. 즉, 임의의 레코드 키와 h값만큼 떨어진 곳의 레코드 키를 비교하여 순서화되어 있지 않으면 서로 교환하는 것을 반복하는 정렬
+ 입력 파일이 부분적으로 정렬되어 있는 경우에 유리한 방식이다.
+ 평균 수행 시간 복잡도는 O(n ^1.5)이고, 최악은 O(n^2)이다.





### 3.3 선택 정렬(Selection Sort)

+ n개의 레코드 중에서 최소값을 찾아 첫 번째 레코드 위치에 놓고, 나머지 (n-1)개 중에서 다시 최소값을 찾아 두 번째 레코드 위치에 놓는 방식을 반복하여 정렬하는 방식
+ O(n^2)





### 3.4 버블 정렬(Bubble Sort)

+ 주어진 파일에서 인접한 두 개의 레코드 키 값을 비교하여 그 크기에 따라 레코드 위치를 서로 교환하는 정렬 방식
+ 계속 정렬 여부를 플래그 비트로 결정한다.
+ 평균과 최악 모두 O(n^2)





### 3.5 퀵 정렬(Quick Sort)

+ 레코드의 많은 자료 이동을 없애고 하나의 파일을 부분적으로 나누어 가면서 정렬하는 방법으로, **키를 기준으로 갖은 값을 왼쪽에, 큰 값을 오른쪽 서브 파일로 분해시키는 방식**으로 정렬한다.
+ 위치에 관계없이 임의의 키를 분할 원소로 사용할 수 있다.
+ 정렬 방식 중에서 가장 빠른 방식이다.
+ 스택이 필요하다.
+ **분할**(Divide)과 **정복**(Conquer)을 통해 자룔를 정렬한다.
  + 분할
    + 기준값인 피봇을 중심으로 정렬할 자료들을 2개의 부분집합으로 나눈다.
  + 정복
    + 부분집합의 원소들 중 피봇보다 작은 원소들은 왼쪽, 피봇보다 큰 원소들은 오른쪽 부분집합으로 정렬한다.
  + 부분집합의 크기가 더 이상 나누어질 수 없을 때까지 분할과 정복을 반복 수행한다.
+ 평균 수행 시간 복잡도는 O(nlogn)이고, 최악의 수행 시간 복잡도는 O(n^2)이다.





### 3.6 힙 정렬

+ 힙 정렬은 전이진 트리를 이용한 정렬 방식이다.
+ 구성된 전이진 트리를 힙 트리로 변환하여 정렬한다.
  + 전이진 트리의 노드의 역순으로 자식 노드와 부모 노드를 비교하면서 큰 값을 위로 올린다.
  + 교환된 노드들을 다시 검토하여 위 작업을 반복한다.
+ 평균과 최악 모두 O(nlogn)이다.





### 3.7 2-Way 합병 정렬

+ 이미 정렬되어 있는 두 개의 파일을 한 개의 파일로 합병하는 정렬 방식이다.
+ 두 개의 키들을 한 쌍으로 하여 각 쌍에 대하여 순서를 정렬한다.
+ 순서대로 정렬된 각 쌍의 키들을 합병하여 하나의 정렬된 서브리스트로 만든다.
+ 위 과정에서 정렬된 서브리스트들을 하나의 정렬된 파일이 될 때까지 반복한다.
+ 평균과 최악 모두 O(nlogn)이다.





### 3.8 기수 정렬

+ Queue를 이용하여 자릿수별로 정렬하는 방식이다.
+ 레코드의 키 값을 분석하여 같은 수 또는 같은 문자끼리 그 순서에 맞는 버킷에 분배하였다가 버킷의 순서대로 레코드를 꺼내어 정렬한다.
+ 평균과 최악 모두 시간 복잡도는 O(dn)이다.





## 4. 데이터베이스 개요

### 4.1 데이터 저장소

+ 데이터저장소는 소프트웨어 개발 과정에서 다루어야 할 데이터들을 **논리적인 구조로 조직화하거나, 물리적인 공간에 구축한 것**을 의미한다.
+ 논리 데이터저장소와 물리 데이터저장소로 구분
  + 논리 데이터저장소는 데이터 및 데이터 간의 연관성, 제약조건을 식별하여 논리적인 구조로 조직화한 것
  + 물리 데이터저장소는 논리 데이터저장소에 저장된 데이터와 구조들을 하드웨어적인 저장장치에 저장한 것
+ 데이터저장소의 구축 과정과 데이터베이스의 구축 과정은 동일하다.





### 4.2 데이터베이스

+ DB는 특정 조직의 업무를 수행하는 데 필요한 상호 관련된 데이터들의 모임으로 다음과 같이 정의할 수 있다.
+ **통합된 데이터**: 자료의 중복을 배제한 데이터의 모임
+ **저장된 데이터**: 컴퓨터가 접근할 수 있는 저장 매체에 저장된 자료
+ **운영 데이터**: 조직의 고유한 업무를 수행하는 데 존재 가치가 확실. 반드시 필요한 자료
+ **공용 데이터**: 여러 응용 시스템들이 공동으로 소유하고 유지하는 자료





### 4.3 DBMS

+ 사용자와 DB 사이에서 사용자의 요구에 따라 정보를 생성해주고 DB를 관리해주는 소프트웨어
+ 데이터의 **종속성과 중복성 문제**를 해결하기 위해 제안된 시스템
+ 필수 기능에는 **정의, 조작, 제어**가 있다.
  + 정의
    + 저장될 데이터의 형과 구조에 대한 정의, 이용 방식, 제약 조건 등을 명시하는 기능
  + 조작
    + 데이터의 검색, 갱신, 삽입, 삭제 등을 처리하기 위해 인터페이스 수단을 제공하는 기능
  + 제어
    + 무결성이 유지되도록 제어
    + 정당한 사용자가 허가된 데이터에만 접근할 수 있도록 보안을 유지, 권한을 검사
    + 여러 사용자가 DB에 동시에 접근해도 처리 결과가 항상 정확성을 유지하도록 병행 제어를 할 수 있어야 한다.





### 4.4 대표적 장단점

+ 장점
  + 논리적, 물리적 독립성이 보장된다.
  + 중복을 피할 수 있어 기억 공간이 절약된다.
  + 일관성, 무결성, 보안 유지 가능
  + 데이터를 표준화 할 수 있고 통합 관리 가능

+ 단점
  + 전산화 비용 증가
  + 과부하 발생 가능
  + 파일의 **예비**와 **회복**이 어렵다.





### 4.5 스키마

+ DB 구조와 제약 조건에 관한 전반적인 명세를 기술한 메타데이터의 집합
  + DB를 구성하는 데이터 개체, 속성, 관계 및 데이터 조작 시 데이터 값들이 갖는 제약 조건 등에 관해 전반적으로 정의한다.
+ 외부 스키마
  + 사용자나 응용 프로그래머가 각 개인의 입장에서 필요로 하는 DB의 논리적 구조를 정의한 것
+ 개념 스키마
  + 전체적인 논리적 구조
+ 내부 스키마
  + 물리적 저장장치의 입장에서 본 DB구조, 레코드의 형식을 정의하고 항목의 표현 방법, 내부 레코드의 물리적 순서 등을 나타냄







## 5. 데이터 입출력

### 5.1 데이터 입출력의 개요

+ 소프트웨어 기능 구현을 위해 DB에 데이터를 입력하거나 DB의 데이터를 출력하는 작업을 의미한다.
+ **단순 입출력뿐만 아니라** **데이터를 조작하는 모든 행위를 의미**하며 이와 같은 작업을 위해 SQL을 사용한다.

+ 개발 코드에 SQL을 삽입하거나 객체와 데이터를 연결하는 것을 **데이터 접속**(Data Mapping)이라고 한다.
+ SQL을 통한 DB 조작을 수행할 때 논리적 기능을 수행하기 위한 작업의 단위 또는 한꺼번에 모두 수행되어야 할 일련의 연산들을 **트랜잭션**이라고 한다.





### 5.2 SQL

+ 관계대수와 관계해석을 기초로 한 혼합 데이터 언어
+ 질의어지만 질의 기능만이 아닌 데이터 구조의 정의, 조작, 제어 기능을 모두 갖추고 있다.
+ DDL, DML, DCL





### 5.3 데이터 접속

+ 소프트웨어의 기능 구현을 위해 **프로그래밍 코드와 DB 데이터를 연결하는 것**
+ **SQL Mapping**과 **ORM**이 있다.
  + SQL Mapping
    + 프로그래밍 코드 내에 SQL을 직접 입력하여 DBMS에 접근하는 기술, JDBC, ODBC, MyBatis
  + ORM
    + **객체지향 프로그래밍의 객체와 관계형 데이터베이스의 데이터를 연결하는 기술**로, 관련 프레임워크에는 JPA , Hibernate, Django 등이 있다.





### 5.4 트랜잭션

+ **DB의 상태를 변환시키는 하나의 논리적 기능을 수행하기 위한 작업의 단위 또는 한꺼번에 모두 수행되어야 할 일련의 연산들**
+ 트랜잭션을 제어하기 위해 사용하는 명령어를 TCL이라 하며, COMMIT, ROLLBACK, SAVEPOINT가 있다.
  + COMMIT
    + 트랜잭션 처리가 정상적으로 종료되어 트랜잭션이 수행한 변경 내용을 DB에 반영하는 명령어
  + ROLLBACK
    + 트랜잭션 처리가 비정상적으로 종료되어 **DB의 일관성이 깨졌을 때** 트랜잭션이 행한 모든 변경 작업을 취소하고 이전을 되돌리는 명령어
  + SAVEPOINT
    + ROLLBACK으로 돌아갈 저장점을 지정하는 명령어







## 6. 절차형 SQL

### 6.1 절차형 SQL의 개요

+ C, JAVA 등의 프로그래밍 언어와 같이 연속적인 실행이나 분기, 반복 등의 제어가 가능한 SQL을 의미한다.

+ 일반적인 프로그래밍 언어에 비해 효율은 떨어지지만 단일 SQL 문장으로 처리하기 어려운 연속적인 작업들을 처리하는데 적합하다.

+ **BEGIN ~ END 형식**으로 작성되는 **블록 구조**로 되어 있기 때문에 **기능별 모듈화가 가능**하다.

+ 종류로는 프로시저, 트리거, 사용자 정의 함수가 있다.

  + **프로시저**
    + 특정 기능을 수행하는 일종의 **트랜잭션 언어**로, 호출을 통해 실행되어 미리 저장해놓은 SQL작업 수행

  + **트리거**
    + DB에서 데이터의 입력, 갱신, 삭제 등의 **이벤트**가 발생할 때마다 관련 작업이 자동으로 수행된다.
  + **사용자 정의 함수**
    + 프로시저와 유사하게 SQL을 사용하여 일련의 작업을 연속적으로 처리하며, 종료 시 예약어 Return을 사용하여 처리 결과를 단일값으로 반환한다.





### 6.2 절차형 SQL의 테스트와 디버깅

+ 디버깅
  + 오류를 잡기 위해 소스 코드를 한 줄 한 줄 추적해 가며 변수 값의 변화를 검사하는 작업
+ 절차형 SQL은 디버깅을 통해 기능의 **적합성 여부를 검증**하고, 실행을 통해 **결과를 확인하는 테스트 과정** 수행

+ 테스트 전에 생성을 통해 **구문 오류**나 **참조 오류**의 존재 여부를 확인한다. 
+ SHOW 명령어를 통해 내용을 확인하고 문제를 수정한다.
+ 정상적으로 생성된 SQL은 **디버깅**을 통해 로직을 검증하고, 결과를 통해 최종적으로 확인한다.
+ 디버깅은 실제로 출력문을 이용하여 화면에 출력하여 확인
+ 디버깅 시 DB 데이터들이 변경되지 않도록 관련 코드들은 주석처리하고 실행한다.





### 6.3 쿼리 성능 최적화

+ 데이터 입출력 애플리케이션의 성능 향상을 위해 SQL코드를 최적화 하는 것
+ 성능 측정 도구인 **APM**을 사용하여 최적화 할 쿼리를 선정한다.
+ 최적화 할 쿼리에 대해 **옵티마이저**가 수립한 실행 계획을 검토하고 재구성한다.