# [소프트웨어 설계] - 3) 애플리케이션 설계

 





## 1. 소프트웨어 아키텍처

소프트웨어의 골격이 되는 기본 구조이자, 소프트웨어를 구성하는 요소들 간의 관계를 표현하는 시스템의 구조 또는 구조체이다.

+ 상위 설계
  + 아키텍처 설계, 예비 설계
  + 시스템의 전체적인 구조
  + 구조, DB, 인터페이스
+ 하위 설계
  + 모듈, 상세 설계
  + 시스템의 내부 구조 및 행위
  + 컴포넌트, 자료 구조, 알고리즘

### 1.1 모듈화

소프트웨어의 성능을 향상시키거나 시스템의 수정 및 재사용, 유지 관리 등이 용이하도록 시스템의 기능들을 모듈 단위로 나누는 것을 의미한다.

+ 모듈 : 전체 프로그램의 기능 중에 특정 기능을 처리할 수 있는 소스 코드
+ 모듈의 크기가 크면 통합 비용은 적어지는 대신에 하나의 개발 비용이 커지게 된다.

<br/>

<br/>

### 1.2 추상화

문제의 전체적이고 포괄적인 개념을 설계한 후 차례로 세분화하여 구체화시켜 나가는 것이다.

<br/>

<br/>

### 1.3 단계적 분해

하향식 설계 전략으로, 문제를 상위의 중요 개념으로부터 하위의 개념으로 구체화시키는 분할 기법이다.

+ 추상화의 반복에 의해 세분화된다.

<br/>

<br/>

### 1.4 정보 은닉

<br/>

<br/>

<br/>

## 2. 아키텍처 패턴

### 2.1 레이어 패턴

시스템을 계층( Layer)로 구분하여 구성하는 고전적인 방법 중 하나이다.

+ 각각의 서브시스템들이 계층 구조를 이루며, 상위 계층은 하위 계층에 대한 서비스 제공자가 되고, 하위 계층은 상위 계층의 클라이언트가 된다.
+ 마주보는 두 계층 사이에서만 상호작용이 이루어진다. 변경 작업이 용이하다.
+ 대표적으로 OSI 참조 모델이 있다.

<br/>

<br/>

### 2.2 클라이언트-서버 패턴

하나의 서버 컴포넌트와 다수의 클라이언트 컴포넌트로 구성되는 패턴이다.

+ 사용자는 클라이언트와만 의사소통을 한다. 즉, 사용자가 클라이언트를 통해 서버에 요청하고 클라이언트가 응답을 받아 사용자에게 제공하는 방식으로 서비스를 제공한다.

<br/>

<br/>

### 2.3 파이프-필터 패턴

데이터 스트림 절차의 각 단계를 필터 컴포넌트로 캡슐화하여 파이프를 통해 데이터를 전송하는 패턴이다.

+ 재사용성이 좋고, 추가가 쉬워 확장이 용이하다.
+ 필터 컴포넌트들을 재배치하여 다양한 파이프라인을 구축하는 것이 가능하다.
+ 파이프 필터 패턴은 데이터 변환, 버퍼링, 동기화 등에 주로 사용된다.

<br/>

<br/>

### 2.4 모델-뷰-컨트롤러 패턴

서브시스템을 3개의 부분으로 구조화하는 패턴이며, 각 부분의 역할은 다음과 같다.

+ 모델
  + 서브시스템의 핵심 기능과 데이터를 보관한다.
+ 뷰
  + 사용자에게 정보를 표시한다.
+ 컨트롤러
  + 사용자로부터 받은 입력을 처리한다.

+ 모델-뷰-컨트롤러 패턴의 각 부분은 별도의 컴포넌트로 분리되어 있으므로 서로 영향을 받지 않고 개발 작업을 수행할 수 있다.
+ 모델-뷰-컨트롤러 패턴에서는 여러 개의 뷰를 만들 수 있으므로 한 개의 모델에 대해 여러 개의 뷰를 필요로 하는 대화형 애플리케이션에 적합하다.

<br/>

<br/>

<br/>

## 3. 객체지향(중요)

현실 세계의 개체를 기계의 부품처럼 하나의 객체로 만들어, 기계적인 부품들을 조립하여 제품을 만들 듯이 소프트웨어를 개발할 때도 객체들을 조립해서 작성할 수 있는 기법을 말한다.

+ 구조적 기법의 문제점으로 인한 소프트웨어 위기의 해결책으로 채택되어 사용되고 있다.
  + 구조적 기법
    + 프로시저에 근간을 두고 하나의 커다란 작업을 여러 개의 작은 작업으로 분할하고, 분할된 각각의 소작업을 수행하는 모듈을 작성한 다음 이들을 한 곳에 모아 큰 작업을 수행하는 하나의 완벽한 프로그램으로 작성하는 기법
+ 객체, 클래스, 캡슐화, 상속, 다형성, 연관성

### 3.1 객체

데이터와 데이터를 처리하는 함수를 묶어 놓은(캡슐화한) 하나의 소프트웨어 모듈이다.

+ 데이터
  + 객체가 가지고 있는 정보로 속성이나 상태, 분류 등을 나타낸다.
+ 함수
  + 객체가 수행하는 기능으로 객체가 갖는 데이터를 처리하는 알고리즘이다.
+ 객체의 특성
  + 객체는 독립적으로 식별 가능한 이름을 가지고 있다.
  + 객체가 가질 수 있는 조건을 상태라고 하는데, 일반적으로 상태는 시간에 따라 변한다.
  + 객체와 객체는 상호 연관성에 의한 관계가 형성된다.
  + 객체의 메소드는 다른 객체로부터 메시지를 받았을 때 정해진 기능을 수행한다.

<br/>

<br/>

### 3.2 클래스

공통된 속성과 연산(행위)을 갖는 객체의 집합으로, 객체의 일반적인 타입을 의미한다.

+ 클래스는 각각의 객체들이 갖는 속성과 연산을 정의하고 있는 틀이다.
+ 객체지향 프로그램에서 데이터를 추상화하는 단위이다.
+ 클래스에 속한 각각의 객체를 인스턴스라고 하며, 클래스로부터 새로운 객체를 생성하는 것을 인스턴스화라고 부른다.
+ 슈퍼 클래스는 특정 클래스의 상위(부모) 클래스이고, 서브 클래스는 특정 클래스의 하위(자식) 클래스이다.

<br/>

<br/>

### 3.3 캡슐화

데이터(속성)와 데이터를 처리하는 함수를 하나로 묶는 것을 의미한다.

+ 캡슐화된 객체는 인터페이스를 제외한 세부 내용이 은폐(정보 은닉)되어 외부에서의 접근이 제한적이기 떄문에 외부 모듈의 변경으로 인한 파급 효과가 적다.

<br/>

<br/>

### 3.4 상속

이미 정의된 상위 클래스의 모든 속성과 연산을 하위 클래스가 물려받는 것이다.

+ 다중 상속
  + 한 개의 클래스가 두 개 이상의 상위 클래스로부터 속성과 연산을 상속받는 것이다.

<br/>

<br/>

### 3.5 다형성

메시지에 의해 객체가 연산을 수행하게 될 때 하나의 메시지에 대해 각각의 객체가 가지고 있는 고유한 방법으로 응답할 수 있는 능력을 의미한다.

<br/>

<br/>

### 3.6 연관성

두 개 이상의 객체들이 상호 참조하는 관계를 말하며 종류는 다음과 같다.

+ is member of
  + 연관화
+ is instance of
  + 분류화
+ is part of
  + 집단화
+ is a
  + 일반화
  + 특수화/상세화

<br/>

<br/>

<br/>

## 4. 객체지향 분석 및 설계

객체지향 분석(OOA)은 사용자의 요구사항을 분석하여 요구된 문제와 관련된 모든 클래스, 이와 연관된 속성과 연산, 그들 간의 관계 등을 정의하여 모델링하는 작업이다.

### 4.1 객체지향 분석 방법론

+ 럼바우 방법
  + 가장 일반적으로 사용되는 방법으로 분석 활동을 객체 모델, 동적 모델, 기능 모델로 나누어 수행하는 방법이다.
+ 부치 방법
  + 미시적 개발 프로세스와 거시적 개발 프로세스를 모두 사용하는 분석 방법으로, 클래스와 객체들을 분석 및 식별하고 클래스의 속성과 연산을 정의한다.
+ Jcobson 방법
  + Use Case를 강조하여 사용하는 분석 방법이다.
+ Coad와 Yourdon 방법
  + E-R 다이어그램을 사용하여 객체의 행위를 모델링
+ Wirfs-Brock 방법
  + 분석과 설계 간의 구분이 없고, 고객 명세서를 평가해서 설계 작업까지 연속적으로 수행

<br/>

<br/>

### 4.2 럼바우의 분석 기법

모든 소프트웨어 구성 요소를 그래픽 표기법을 이용하여 모델링하는 기법으로, 객체 모델링 기법이라고도 한다.

+ 객-동-기 순을 통해 분석 활동이 이루어진다.
+ 객체 모델링
  + 정보 모델링이라고도 하며, 시스템에서 요구되는 객체를 찾아내어 속성과 연산 식별 및 객체들 간의 관계를 규정하여 객체 다이어그램으로 표시하는 것이다.
+ 동적 모델링
  + 상태 다이어그램을 이용하여 시간의 흐름에 따른 객체들 간의 제어 흐름, 상호 작용, 동작 순서 등의 동적인 행위를 표현하는 모델링이다.
+ 기능 모델링
  + 자료 흐름도를 이용하여 다수의 프로세스들 간의 자료 흐름을 중심으로 처리 과정을 표현한 모델링이다.

<br/>

<br/>

### 4.3 객체지향 설계 원칙

+ 단일 책임 원칙
+ 개방-폐쇄 원칙
+ 리스코프 치환 원칙
+ 인터페이스 분리 원칙
+ 의존 역전 원칙

<br/>

<br/>

<br/>

## 5. 모듈

모듈화를 통해 분리된 시스템의 각 기능들로, 서브 루틴, 서브 시스템, 소프트웨어 내의 프로그램, 작업 단위 등과 같은 의미로 사용된다.

### 5.1 결합도

모듈 간에 상호 의존하는 정도 또는 두 모듈 사이의 연관 관계를 의미한다.

+ 결합도가 약할수록 품질이 높고, 강할수록 품질이 낮다.
+ 결합도가 강하면 시스템 구현 및 유지보수 작업이 어렵다.
+ 결합도의 종류에는 자료 결합도, 스탬프 결합고, 제어 결합도, 외부 결합도, 공통 결합도, 내용 결합도가 있으면 결합도의 정도는 다음과 같다.
  + 자료, 스탬프, 제어, 외부, 공통, 내용 순으로 결합도가 강함(내용 결합도가 제일 강함)

<br/>

<br/>

### 5.2 응집도

정보 은닉 개념을 확장한 것으로, 명령어나 호출문 등 모듈의 내부 요소들이 서로 관련되어 있는 정도, 즉 모듈이 독립적인 기능으로 정의되어 있는 정도를 의미한다.

+ 응집도 강할수록 품질이 높고, 약할수록 품질이 낮다.
+ 기능적, 순차적, 교환적, 절차적, 시간적, 논리적, 우연적 순으로 응집도가 낮다.

<br/>

<br/>

### 5.3 팬인 / 팬아웃

+ 팬인은 어떤 모듈을 제어하는 모듈의 수를 나타낸다.
+ 팬아웃은 어떤 모듈에 의해 제어되는 모듈의 수를 나타낸다.
+ 팬인과 팬아웃을 분석하여 시스템의 복잡도를 알 수 있다.
+ 팬인이 높다는 것은 재사용 측면에서 설계가 잘 되어있다고 볼 수 있으나, 단일 장애점이 발생할 수 있으므로 중점적인 관리 및 테스트가 필요하다.
+ 팬아웃이 높은 경우 불필요하게 다른 모듈을 호출하고 있는지 검토하고, 단순화시킬 수 있는지 여부에 대한 검토가 필요하다.

