# [데이터베이스 구축] - 2)논리 데이터베이스 구축







## 1. 물리 데이터베이스 설계

+ 논리적 구조로 표현된 논리적 DB를 디스크 등의 물리적 저장장치에 저장할 수 있는 물리적 구조의 데이터로 변환하는 과정
+ 물리적 DB 구조의 **기본적인 데이터 단위**는 **저장 레코드**(stored record)이다.
+ 꼭 포함되어야 할 단계
  + **레코드의 양식 설계, 레코드 집중의 분석 및 설계, 접근 경로 설계**

+ 물리 DB구조는 **DB 시스템의 성능에 중대한 영향을 미친다.**
+ 고려 사항
  + **인덱스 구조, 레코드 크기, 파일에 대한 트랜잭션 갱신과 참조 성향, 성능 향상을 위한 개념 스키마 변경 여부 검토** 등
+ 물리적 설계 전에 기존 시스템을 분석하여 **데이터 명명 규칙**, **시스템 자원**, **데이터 베이스 관리 요소** 등을 파악해야 한다.

### 1.1 데이터 명명 규칙 파악

+ 물리 데이터 모델에 적용해야 하는 규칙으로, 조직마다 다를 수 있으므로 데이터 모델의 설계 전에 파악해야 한다.

+ **데이터 표준화** 및 **논리 DB 설계의 결과물** 등을 통해 파악

+ 물리 DB 설계와 논리 DB 설계에 적용되는 명명 규칙은 서로 일관성을 유지해야 한다.

+ 데이터 명명 규칙을 통해 **중복 구축 등을 방지**할 수 있다.

+ 명명 규칙을 파악하려면 도메인과 데이터 사전에 대한 지식 필요

  + 도메인
    + 객체에 포함된 **속성들의 데이터 타입, 크기** 등을 표준화 규칙에 따라 일관성 있게 정의한 것
  + 데이터 사전
    + 전체 프로젝트 과정에서 일관성 있는 데이터 이름과 인터페이스를 제공하기 위해 **속성의 논리명, 물리명, 용어 정의를 기술해 놓은 것**

  

  

### 1.2 시스템 자원 파악

+ 시스템 자원은 DB 설치에 영향을 미칠 수 있는 물리적인 요소들로, 사전에 미리 파악해야 한다.

+ 시스템 자원은 **하드웨어 자원, 운영체제 및 DBMS 버전, DBMS 파라미터 정보** 등으로 구분한다.





### 1.3 데이터베이스 관리 요소 파악

+ DB 관리 요소는 **DB 운영과 관련된 관리 요소**로, **DB 시스템의 환경에 따라 달라질 수 있으므로** 미리 파악해야 한다.
+ 시스템 조사 분석서를 기반으로 DB구조, 이중화 구성, 분산 DB, 접근제어/접근통제, DB 암호화 등의 범위와 특성을 파악한다.







## 2. 데이터베이스 저장 공간 설계

### 2.1 테이블

+ DB의 가장 기본적인 객체로 Row, Column으로 구성되어 있다.
  + DB의 모든 데이터는 테이블에 저장된다.
  + 논리 설계 단계의 **개체에 대응하는 객체**이다.
  + 일반 테이블, 클러스터 인덱스 테이블, 파티셔닝 테이블, 외부 테이블, 임시 테이블 등이 있다.





### 2.2 일반 테이블

+ 현재 사용되는 대부분의 DBMS에서 표준 테이블로 사용되는 테이블 형태
+ 테이블에 저장되는 데이터의 Row 위치는 속성 값에 상관없이 데이터가 저장되는 순서에 따라 결정된다.





### 2.3 클러스터드 인덱스 테이블

+ 기본키나 인덱스키의 순서에 따라 데이터가 저장되는 테이블
  + 일반적인 인덱스를 사용하는 테이블에 비해 **접근 경로가 단축된다.**





### 2.4 파티셔닝 테이블

+ 대용량의 테이블을 작은 논리적 단위인 파티션으로 나눈 테이블
+ 대용량의 데이터를 효과적으로 관리할 수 있지만 **파티션 키를 잘못 구성하면 성능 저하** 등의 역효과 초래 가능

+ 파티셔닝 방식에 따라 **범위 분할**, **해시 분할**, **조합 분할** 등으로 나뉜다.
  + 범위 분할: 지정한 열의 값을 기준으로 분할
  + 해시 분할: 해시 함수를 적용한 결과 값에 따라 데이터를 분할
  + 조합 분할: 범위 분할로 분할한 다음 해시 함수를 적용하여 다시 분할





### 2.5 외부 테이블

+ DB에서 일반 테이블처럼 이용할 수 있는 외부 파일로, DB 내에 객체로 존재한다.
+ 데이터웨어하우스에서 ETL 등의 작업에 유용하게 사용된다.
  + 데이터웨어하우스: 조직이나 기업체의 중심이 되는 주요 업무 시스템에서 추출되어 새로이 생성된 DB
  + ETL: 데이터웨어하우스를 사용하여 **추출**, **변환**, **적재** 하는 일련의 모든 과정





### 2.6 임시 테이블

+ 트랜잭션이나 세션별로 데이터를 저장하고 처리할 수 있는 테이블
+ 임시 테이블에 저장된 데이터는 트랜잭션이 종료되면 삭제





### 2.7 컬럼

+ 컬럼은 테이블의 열을 구성하는 요소로 **데이터 타입, 길이** 등으로 정의된다.
+ **데이터의 일관성 유지를 위해 사용되는 가장 기본적인 것으로, 도메인을 정의한 경우 도메인에 따라 데이터 타입과 길이가 정의된다.**
+ 데이터 타입이나 길이가 다른 칼럼끼리 연산을 하면 DBMS가 내부적으로 데이터 타입 변환 후 연산 수행
+ 데이터 타입과 길이 지정 시 고려 사항
  + 가변 길이 데이터 타입: 예상되는 최대 길이로 정의
  + 고정 길이 데이터 타입: 최소 길이로 지정
  + 소수점 이하 자릿수: 소수점 이하 자릿수는 반올림되어 저장
+ **데이터 타입에 따른 칼럼의 물리적인 순서**
  + 고정 길이 컬럼이고 NOT Null인 컬럼: 앞쪽
  + 가변 길이 컬럼: 뒤쪽
  + Null 값이 많을 것으로 예상되는 칼럼: 뒤쪽





### 2.8 테이블스페이스

+ 테이블이 저장되는 논리적인 영역으로, 하나의 테이블스페이스에 하나 또는 그 이상의 테이블을 저장할 수 있다.
+ 테이블을 저장하면 **논리적으로는 테이블스페이스에 저장**되고, **물리적으로는** 해당 테이블스페이스와 연관된 **데이터 파일에 저장**된다.
  + 즉, **테이블스페이스 - 논리적 영역**, **데이터 파일 - 물리적 영역**
+ DB를 **테이블, 테이블스페이스, 데이터 파일**로 나눠 관리하면 논리적 구성이 물리적 구성에 종속되지 않아 **투명성이 보장**된다.
  + **투명성**: 어떠한 사실이 존재함에도 사실의 존재 여부를 염두에 두지 않도 되는 성질







## 3. 트랙잭션 분석 / CRUD 분석

### 3.1 트랜잭션 정의

+ 트랜잭션은 DB의 상태를 변환시키는 하나의 논리적 기능을 수행하기 위한 작업의 단위 또는 한꺼번에 모두 수행되어야 할 일련의 연산들을 의미한다.
+ 트랜잭션은 DB시스템에서 **병행 제어** 및 **회복 작업** 시 처리되는 작업의 논리적 단위로 사용된다.
+ 트랜잭션은 사용자가 시스템에 대한 서비스 요구 시 시스템이 응답하기 위한 **상태 변환 과정의 작업 단위**로 사용된다.





### 3.2 트랜잭션의 특성 (매우 중요)

+ 데이터의 무결성을 보장하기 위하여 DBMS의 트랜잭션이 가져야 할 특성

| 특성                                   | 내용                                                         |
| -------------------------------------- | ------------------------------------------------------------ |
| Atomicity(원자성)                      | 트랜잭션의 연산은 DB에 모두 반영(commit)되던지,<br/>전혀 반영되지 않도록 복구(Rollback)되어야 한다. <br/>트랜잭션 내의 모든 명령은 반드시 완벽히 수행되어야 하며,<br/>어느 하나라도 오류가 발생하면 트랜잭션 전부가 취소되어야 한다. |
| Consistency(일관성)                    | 트랜잭션의 실행이 성공적이면 DB는 언제나 일관성 있는 상태이다.<br/>시스템이 가지고 있는 고정 요소는 트랜잭션 수행 전과 후의 상태가 같다. |
| Isolation<br/>(독립성, 격리성, 순차성) | 둘 이상의 트랜잭션이 동시에 병행 실행되는 경우 <br/>어느 하나의 실행 중 다른 트랜잭션의 연산이 끼어들 수 없다.<br/>수행중인 트랜잭션은 완전히 완료될 때까지 다른 트랜잭션에서<br/>수행 결과를참조할 수 없다. |
| Durability(영속성, 지속성)             | 성공적으로 완료된 트랜잭션의 결과는 시스템이 고장나더라도 영구 반영된다. |





### 3.3 CRUD 분석

+ CRUD란 Create, Read, Update, Delete의 약어다. CRUD 분석은 DB 테이블에 변화를 주는 트랜잭션의 CRUD 연산에 대해 **CRUD 매트릭스를 작성하여 분석하는 것**이다.
+ CRUD 분석으로 **테이블에 발생되는 트랜잭션의 주기별 발생 횟수**를 파악하고 **데이터의 양을 유추**할 수 있다.
+ **트랜잭션이 몰리는 테이블을 파악**할 수 있으므로 디스크 구성 시 유용한 자료를 얻을 수 있다.
+ **외부 프로세스 트랜잭션의 부하가 집중되는 DB 채널을 파악**하고 **분산**시킴으로써 연결 지연이나 타임아웃 오류를 방지





### 3.4 CRUD 매트릭스

+ 2차원 형태의 표로서, 행에는 **프로세스**, 열에는 **테이블**, 교차점에는 **프로세스가 테이블에 발생시키는 변화**를 표시하는 업무 프로세스와 데이터 간 상관 분석표

+ 각 셀에는 C, R, U, D가 들어가며 복수의 변화를 줄 때는 기본적으로 C > D > U > R의 우선순위를 적용해 한 가지만 적는다. 활용 목적에 따라 모두 기록할 수도 있다.
+ CRUD 매트릭스가 완성되었다면 CRUD 중 어느 것도 적히지 않은 행이나 열, C나 R이 없는 열을 확인하여 불필요하거나 누락된 테이블 또는 프로세스를 찾는다.
  + **행(프로세스)가 C나 R이 없는 것은 문제 없다.**





### 3.5 트랜잭션 분석

+ CRUD 매트릭스를 기반으로 테이블에 발생하는 트랜잭션 양을 분석하여 테이블에 저장되는 데이터 양을 유추하고 이를 근거로 DB 용량을 산정하고 DB구조를 최적화 하는 것
+ **업무 개발 담당자가 수행**





### 3.6 트랜잭션 분석서

+ **단위 프로세스**와 **CRUD 매트릭스**를 이용해 작성, 구성 요소에는 단위 프로세스, CRUD 연산, 테이블명, 컬럼명, 테이블 참조 횟수, 트랜잭션 수, 발생 주기 등이 있다.
+ **단위 프로세스**
  + 업무를 발생시키는 가장 작은 단위의 프로세스







## 4. 인덱스 설계

+ 인덱스는 데이터 레코드를 빠르게 접근하기 위해 **<키 값, 포인터>** 쌍으로 구성되는 데이터 구조다.
  + ex) 키 값은 학번이고, 포인터는 해당 학번이 저장된 **레코드의 물리적 주소**
+ 인덱스는 데이터가 저장된 **물리적 구조와 밀접한 관계**가 있다.
  + 레코드가 저장된 물리적 구조에 접근하는 방법을 제공
+ 레코드의 삽입과 삭제가 수시로 일어나면 인덱스의 개수를 **최소**로 하는 것이 효율적
+ **인덱스가 없으면** 특정 값을 찾기 위해 모든 데이터 페이지를 확인하는 **TABLE SCAN**이 발생한다.
+ **기본키를 위한 인덱스는 기본 인덱스**, 이외는 **보조 인덱스**라고 한다.
+ **레코드의 물리적 순서가 인덱스의 엔트리 순서와 일치**하게 유지되도록 구성되는 인덱스를 **클러스터드 인덱스**라고 한다.

### 4.1 트리 기반 인덱스

+ 인덱스를 저장하는 블록들이 트리 구조를 이루고 있는 것, 상용 DBMS에서는 B+ 트리 인덱스를 주로 활용
+ B트리 인덱스
  + 일반적, 루트 노드에서 하위 노드로 키 값의 크기를 비교해 나가면서 단말 노드에서 찾고자 하는 데이터를 검색
  + 키 값과 레코드를 가리키는 포인터들이 트리 노드에 **오름차순**으로 저장된다.
+ B+트리 인덱스
  + B트리의 변형으로 단말 노드가 아닌 노드로 구성된 **인덱스 세트**와 단말 노드로만 구성된 **순차 세트**로 구분된다.
  + **순차 세트는 단말 노드에 있는 키 값을 찾아가기 위한 경로로만 제공되며, 순차 세트에 있는 단말 노드가 해당 데이터 레코드의 주소를 가리킨다.**





### 4.2 비트맵 인덱스

+ 인덱스 컬럼의 데이터를 Bit값인 0또는 1로 변환하여 인덱스 키로 사용하는 방법
+ 목적은 **키 값을 포함하는 로우의 주소를 제공**하는 것
+ 분포도가 좋은 컬럼에 적합하며 성능 향상 효과를 얻을 수 있다.





### 4.3 함수 기반 인덱스

+ 컬럼의 값 대신 컬럼에 특정 함수나 수식을 적용하여 산출된 값을 사용
+ **시스템 함수를 사용하면 사용자 정의 함수를 사용할 때 보다 부하가 덜 발생한다.**





### 4.4 비트맵 조인 인덱스

+ 다수의 조인된 객체로 구성된 인덱스로, 단일 객체로 구성된 일반적인 인덱스와 액세스 방법이 다르다.





### 4.5 도메인 인덱스

+ 개발자가 필요한 인덱스를 직접 만들어 사용하는 것으로, 확장형 인덱스라고도 한다.





### 4.6 인덱스 설계

1. 인덱스의 대상 테이블이나 컬럼 등을 선정
2. 인덱스의 효율성을 검토하여 인덱스 최적화를 수행
3. 인덱스 정의서를 작성

+ 인덱스 대상 테이블 선정 기준
  + **MULTI BLOCK READ** 수에 따라 판단
    + 테이블 액세스 시 메모리에 한 번에 읽어 들일 수 있는 블록의 수
  + 랜덤 액세스가 빈번한 테이블
+ 인덱스 대상 컬럼 선정 기준
  + 인덱스 컬럼의 분포도가 10~15% 이내인 컬럼
  + ORDER BY, GROUP BY, UNION이 빈번한 컬럼
+ 인덱스 설계 시 고려사항
  + 새로 추가되는 인덱스는 기존 액세스 경로에 영향을 미칠 수 있다.
  + 인덱스를 지나치게 많이 만들면 오버헤드가 발생
  + **인덱스와 테이블 데이터의 저장 공간이 분리되도록 설계한다.**
  + **처음부터 완벽히 설계할 수 없다.**







## 5. 뷰 설계(중요)

### 5.1 뷰 개요

+ 뷰는 **사용자에게 접근이 허용된 자료만을** 제한적으로 보여주기 위해 **하나 이상의 기본 테이블로부터 유도된**, **이름을 가지는 가상 테이블**

+ 뷰는 저장장치 내에 **물리적으로 존재하지는 않지만**, 사용자에게는 있는 것처럼 간주
+ 데이터 보정 작업, 처리 과정 시험 등 **임시적인 작업을 위한 용도로 활용**
+ **조인문의 사용 최소화**로 사용상의 편의성을 최대화
+ 뷰를 생성하면 뷰 정의가 시스템 내에 저장되었다가 **생성된 뷰 이름을 질의어에서 사용할 경우** 질의어가 실행될 때 **뷰에 정의된 기본 테이블로 대체되어 기본 테이블에 대해 실행**된다.

+ 뷰 A가 테이블 1, 2, 3에서 유도되어 생성되면 뷰 A를 통해 테이블 1, 2, 3에 대한 데이터에 접근할 수 있다.





### 5.2 뷰의 특징

+ 뷰는 기본 테이블로부터 유도된 테이블이기 때문에 **기본 테이블과 같은 형태의 구조를 사용하며 조작도 같다.**
+ 물리적으로 구현되어 있지 않다.
+ **데이터의 논리적 독립성을 제공할 수 있다.**
+ 필요한 데이터만 뷰로 정의해서 처리할 수 있기 때문에 관리가 용이하고 명령문이 간단해진다.
+ **기본 테이블의 기본키를 포함한 속성(열) 집합으로 뷰를 구성해야만 삽입, 삭제, 갱신 연산이 가능**
+ 일단 정의된 뷰는 다른 뷰의 정의에 기초가 될 수 있다.
+ 뷰를 정의할 때는 CREATE문, 제거할 때는 DROP문





### 5.3 뷰의 장단점

+ 장점
  + **논리적 데이터 독립성** 제공
  + **동일 데이터에 대해 동시에 여러 사용자의 상이한 응용이나 요구를 지원**
  + 사용자의 **데이터 관리를 간단**하게
  + **접근 제어를 통한 자동 보안 제공**
+ 단점
  + **독립적인 인덱스를 가질 수 없다.**
  + 뷰의 **정의를 변경할 수 없다.**
  + 뷰로 구성된 내용에 삽입, 삭제, 갱신 **연산에 제약**이 따른다.





### 5.4 뷰 설계 순서

1. 대상 테이블을 선정
   + 외부 시스템과 인터페이스에 관여하는 테이블
   + CRUD 매트릭스를 통해 여러 테이블이 동시에 자주 조인되어 접근되는 테이블
   + SQL문 작성 시 거의 모든 문장에서 인라인 뷰 방식으로 접근되는 테이블
2. 대상 컬럼을 선정
   + 보안을 유지해야 하는 컬럼은 주의하여 선별
3. 정의서를 작성





### 5.5 뷰 설계 시 고려 사항

+ 테이블 구조가 단순화 될 수 있도록 반복적으로 조인을 설정하여 사용하거나 동일한 조건절을 사용하는 테이블을 뷰로 생성
+ 데이터의 보안 유지를 고려







## 6. 클러스터 설계

+ 클러스터는 데이터 저장 시 데이터 액세스 효율을 향상시키기 위해 **동일한 성격의 데이터를 동일한 데이터 블록에 저장하는 물리적 저장 방법**

+ 데이터 조회 속도는 향상시키지만, **데이터 입력, 수정, 삭제에 대한 성능은 저하**시킨다.
+ 데이터의 분포도가 넓을수록 유리하다.